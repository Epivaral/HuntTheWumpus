{"ast":null,"code":"const BOARD_SIZE = 20;\nconst NUM_BATS = 1;\nconst NUM_PITS = 1;\nfunction getRandomEmptyCell(occupied, forbidden = new Set()) {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`) || forbidden.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return {\n    x,\n    y\n  };\n}\nfunction markForbiddenArea(center, forbidden, skipCenter = false) {\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      const x = center.x + dx;\n      const y = center.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        if (skipCenter && dx === 0 && dy === 0) continue;\n        forbidden.add(`${x},${y}`);\n      }\n    }\n  }\n}\nexport function createNewGame(stats) {\n  const occupied = new Set();\n  const forbidden = new Set();\n  // Place wall clusters (I, L, T shapes)\n  const NUM_WALLS = Math.floor(BOARD_SIZE * BOARD_SIZE * 0.10); // 10% of the board\n  const wallPositions = [];\n  const wallShapes = [\n  // I shapes (vertical, horizontal)\n  [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: 1\n  }, {\n    dx: 0,\n    dy: 2\n  }], [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: 1,\n    dy: 0\n  }, {\n    dx: 2,\n    dy: 0\n  }],\n  // L shapes (4 rotations)\n  [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: 1,\n    dy: 0\n  }, {\n    dx: 1,\n    dy: 1\n  }], [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: 1\n  }, {\n    dx: 1,\n    dy: 1\n  }], [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: -1,\n    dy: 0\n  }, {\n    dx: -1,\n    dy: 1\n  }], [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: 1\n  }, {\n    dx: -1,\n    dy: 1\n  }],\n  // T shapes (4 rotations)\n  [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: -1,\n    dy: 1\n  }, {\n    dx: 0,\n    dy: 1\n  }, {\n    dx: 1,\n    dy: 1\n  }], [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: 1\n  }, {\n    dx: 1,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: -1\n  }], [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: -1,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: 1\n  }, {\n    dx: 1,\n    dy: 0\n  }], [{\n    dx: 0,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: -1\n  }, {\n    dx: -1,\n    dy: 0\n  }, {\n    dx: 0,\n    dy: 1\n  }]];\n  let wallCellsPlaced = 0;\n  while (wallCellsPlaced < NUM_WALLS) {\n    // Randomly pick a shape\n    const shape = wallShapes[Math.floor(Math.random() * wallShapes.length)];\n    // Randomly pick a starting cell\n    const x0 = Math.floor(Math.random() * BOARD_SIZE);\n    const y0 = Math.floor(Math.random() * BOARD_SIZE);\n    // Compute all cells for this shape\n    const shapeCells = shape.map(({\n      dx,\n      dy\n    }) => ({\n      x: x0 + dx,\n      y: y0 + dy\n    }));\n    // Check all in bounds and not forbidden/occupied\n    if (shapeCells.every(({\n      x,\n      y\n    }) => x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && !occupied.has(`${x},${y}`) && !forbidden.has(`${x},${y}`))) {\n      shapeCells.forEach(({\n        x,\n        y\n      }) => {\n        wallPositions.push({\n          x,\n          y\n        });\n        forbidden.add(`${x},${y}`);\n        occupied.add(`${x},${y}`);\n        wallCellsPlaced++;\n      });\n    }\n    // Prevent infinite loop if board is too full\n    if (wallCellsPlaced > BOARD_SIZE * BOARD_SIZE * 0.5) break;\n  }\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(agentPos, forbidden);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(wumpusPos, forbidden);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(goldPos, forbidden, true); // skipCenter=true: do not forbid the gold cell itself\n  // Place bats\n  const batPositions = [];\n  for (let i = 0; i < NUM_BATS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    batPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n  // Place pits\n  const pitPositions = [];\n  for (let i = 0; i < NUM_PITS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    pitPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n\n  // Build board\n  const board = Array.from({\n    length: BOARD_SIZE\n  }, (_, y) => Array.from({\n    length: BOARD_SIZE\n  }, (_, x) => {\n    if (wallPositions.some(w => w.x === x && w.y === y)) return {\n      type: 'wall',\n      explored: false\n    };\n    return {\n      type: 'empty',\n      explored: false\n    };\n  }));\n  board[wumpusPos.y][wumpusPos.x] = {\n    type: 'wumpus',\n    explored: false\n  };\n  batPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'bat',\n    explored: false\n  });\n  pitPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'pit',\n    explored: false\n  });\n  // Place gold last so it is never overwritten\n  board[goldPos.y][goldPos.x] = {\n    type: 'gold',\n    explored: false\n  };\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    actionLog: [`Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`, `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`, `Gold at (${goldPos.x + 1},${goldPos.y + 1})`],\n    agentState: createAgentState(agentPos),\n    // Ensure hasGold is always false at game start\n    hasGold: false\n  };\n}\nexport function createAgentState(agentPos) {\n  return {\n    stack: [agentPos],\n    visited: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [{\n  dx: 0,\n  dy: -1\n},\n// up\n{\n  dx: 1,\n  dy: 0\n},\n// right\n{\n  dx: 0,\n  dy: 1\n},\n// down\n{\n  dx: -1,\n  dy: 0\n} // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x, y) {\n  const dirs = shuffle([...DIRS]);\n  return dirs.map(({\n    dx,\n    dy\n  }) => ({\n    x: x + dx,\n    y: y + dy\n  })).filter(({\n    x,\n    y\n  }) => isValid(x, y));\n}\nfunction isValid(x, y) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game, x, y) {\n  let dangerLevel = 0;\n  let adjWumpus = null;\n  let adjBats = 0,\n    adjPits = 0;\n  for (const {\n    x: nx,\n    y: ny\n  } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = {\n        x: nx,\n        y: ny\n      };\n    } else if (t === 'pit') {\n      dangerLevel += 10;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return {\n    dangerLevel,\n    adjWumpus,\n    adjBats,\n    adjPits\n  };\n}\nexport function agentStep(game) {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n\n  // INSTANT WIN: If agent is on the gold position, win immediately\n  if (game.agentPos.x === game.goldPos.x && game.agentPos.y === game.goldPos.y && !agent.hasGold) {\n    let log = game.actionLog ? [...game.actionLog] : [];\n    agent.hasGold = true;\n    log.push(`[GOLD] Agent found the gold! WON! (at ${game.agentPos.x + 1},${game.agentPos.y + 1})`);\n    return {\n      ...game,\n      status: 'won',\n      actionLog: log\n    };\n  }\n\n  // Get current position from top of stack (DFS path)\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // Do not mark wall cells as visited/explored, and treat as stuck if agent is on a wall (defensive)\n  const currCell = game.board[curr.y][curr.x];\n  if (currCell.type === 'wall') {\n    log.push('Agent is stuck on a wall cell. This should not happen.');\n    return {\n      ...game,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = {\n    x: curr.x,\n    y: curr.y\n  };\n  // Log visited cells for debugging\n  const visitedCells = [];\n  for (let y = 0; y < BOARD_SIZE; y++) {\n    for (let x = 0; x < BOARD_SIZE; x++) {\n      if (agent.visited[y][x]) visitedCells.push(`(${x + 1},${y + 1})`);\n    }\n  }\n\n  // Sensory warnings for current cell (before any action)\n  let sensedWumpus = false,\n    sensedPit = false,\n    sensedBat = false;\n  for (const n of getAdjacent(curr.x, curr.y)) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus = true;\n    if (t === 'pit') sensedPit = true;\n    if (t === 'bat') sensedBat = true;\n  }\n  if (sensedWumpus) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // Check for threats at current cell\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'gold' && !agent.hasGold) {\n    agent.hasGold = true;\n    log.push(`Agent found the gold! WON! (at ${curr.x + 1},${curr.y + 1})`);\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'won',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'pit') {\n    log.push(`Agent fell into a pit at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'wumpus') {\n    log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({\n      x,\n      y\n    });\n    // Exclude wall cells from teleport destinations\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) {\n      if (game.board[y][x].type === 'wall') {\n        // Remove any wall cell from empty[] if present\n        const idx = empty.findIndex(pos => pos.x === x && pos.y === y);\n        if (idx !== -1) empty.splice(idx, 1);\n      }\n    }\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = {\n        x: empty[idx].x,\n        y: empty[idx].y\n      };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push(`Agent found the gold! WON! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'pit') {\n        log.push(`Agent fell into a pit at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: pos.x,\n            y: pos.y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible ---\n  const neighbors = getAdjacent(curr.x, curr.y);\n  let shot = false;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return {\n          ...game,\n          status: 'won',\n          actionLog: log\n        };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      shot = true;\n      break; // Only shoot once per step\n    }\n  }\n  // If adjacent to Wumpus but no arrows, just continue exploring\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus2 = false,\n    sensedPit2 = false,\n    sensedBat2 = false;\n  for (const n of neighbors) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus2 = true;\n    if (t === 'pit') sensedPit2 = true;\n    if (t === 'bat') sensedBat2 = true;\n  }\n  if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit2) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat2) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor = null;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    // Use a special marker for gold messages instead of HTML for console compatibility\n    log.push(`[GOLD] You are lucky, gold is near! (at ${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // --- DFS MOVEMENT: Choose next move ---\n  let moved = false;\n  // If gold is adjacent and unvisited and not a wall, move to it immediately\n  if (goldNeighbor && !agent.visited[goldNeighbor.y][goldNeighbor.x] && game.board[goldNeighbor.y][goldNeighbor.x].type !== 'wall') {\n    agent.stack.push(goldNeighbor);\n    moved = true;\n  } else {\n    // Prefer unvisited, non-wall neighbor if gold is not adjacent or already visited\n    for (const n of neighbors) {\n      if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type !== 'wall') {\n        agent.stack.push(n);\n        moved = true;\n        break;\n      }\n    }\n  }\n  // If still no move, backtrack\n  if (!moved) {\n    agent.stack.pop();\n  }\n  // Only mark as visited and log for the cell the agent actually moves to\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    // Only mark as visited if the agent is actually moving to this cell now and it's not a wall\n    if ((game.agentPos.x !== pos.x || game.agentPos.y !== pos.y) && game.board[pos.y][pos.x].type !== 'wall') {\n      agent.visited[pos.y][pos.x] = true;\n      game.explored[pos.y][pos.x] = true;\n    }\n    game.agentPos = {\n      x: pos.x,\n      y: pos.y\n    };\n    // Sensory warnings for new cell (after move)\n    let sensedWumpus2 = false,\n      sensedPit2 = false,\n      sensedBat2 = false;\n    for (const n of neighbors) {\n      const t = game.board[n.y][n.x].type;\n      if (t === 'wumpus') sensedWumpus2 = true;\n      if (t === 'pit') sensedPit2 = true;\n      if (t === 'bat') sensedBat2 = true;\n    }\n    if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedPit2) log.push(`You feel a breeze nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedBat2) log.push(`You hear flapping nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push(`[GOLD] You are lucky, gold is near! (at ${pos.x + 1},${pos.y + 1})`);\n    }\n    // Always check for gold/pit/wumpus at the new cell, even if already visited\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold' && !agent.hasGold) {\n      agent.hasGold = true;\n      log.push(`[GOLD] Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'won',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent tried to move into a wall cell. This should not happen.');\n      return {\n        ...game,\n        status: 'lost',\n        actionLog: log\n      };\n    }\n  } else {\n    // If stack is empty, check for win/loss at current position as well\n    const pos = game.agentPos;\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold' && !agent.hasGold) {\n      agent.hasGold = true;\n      log.push(`[GOLD] Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'won',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent is stuck on a wall cell. This should not happen.');\n      return {\n        ...game,\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    log.push('No moves left. Agent is stuck.');\n    return {\n      ...game,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  return {\n    ...game,\n    actionLog: log\n  };\n}","map":{"version":3,"names":["BOARD_SIZE","NUM_BATS","NUM_PITS","getRandomEmptyCell","occupied","forbidden","Set","x","y","Math","floor","random","has","add","markForbiddenArea","center","skipCenter","dy","dx","createNewGame","stats","NUM_WALLS","wallPositions","wallShapes","wallCellsPlaced","shape","length","x0","y0","shapeCells","map","every","forEach","push","agentPos","wumpusPos","goldPos","batPositions","i","pos","pitPositions","board","Array","from","_","some","w","type","explored","fill","status","actionLog","agentState","createAgentState","hasGold","stack","visited","arrows","path","autoMode","DIRS","shuffle","array","j","getAdjacent","dirs","filter","isValid","detectThreats","game","dangerLevel","adjWumpus","adjBats","adjPits","nx","ny","t","agentStep","agent","log","curr","currCell","visitedCells","sensedWumpus","sensedPit","sensedBat","n","cell","empty","idx","findIndex","splice","newCell","neighbors","shot","sensedWumpus2","sensedPit2","sensedBat2","goldNearby","goldNeighbor","moved","pop","goldNear"],"sources":["/workspaces/HuntTheWumpus/hunt-the-wumpus-react/src/utils/gameLogic.ts"],"sourcesContent":["import { GameState, Cell, CellType, AgentState } from './gameTypes';\n\nconst BOARD_SIZE = 20;\nconst NUM_BATS = 1;\nconst NUM_PITS = 1;\n\nfunction getRandomEmptyCell(occupied: Set<string>, forbidden: Set<string> = new Set()): { x: number; y: number } {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`) || forbidden.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return { x, y };\n}\n\nfunction markForbiddenArea(center: {x: number, y: number}, forbidden: Set<string>, skipCenter = false) {\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      const x = center.x + dx;\n      const y = center.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        if (skipCenter && dx === 0 && dy === 0) continue;\n        forbidden.add(`${x},${y}`);\n      }\n    }\n  }\n}\n\nexport function createNewGame(stats: { games: number; victories: number }): GameState {\n  const occupied = new Set<string>();\n  const forbidden = new Set<string>();\n  // Place wall clusters (I, L, T shapes)\n  const NUM_WALLS = Math.floor(BOARD_SIZE * BOARD_SIZE * 0.10); // 10% of the board\n  const wallPositions: { x: number; y: number }[] = [];\n  const wallShapes = [\n    // I shapes (vertical, horizontal)\n    [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:0,dy:2} ],\n    [ {dx:0,dy:0}, {dx:1,dy:0}, {dx:2,dy:0} ],\n    // L shapes (4 rotations)\n    [ {dx:0,dy:0}, {dx:1,dy:0}, {dx:1,dy:1} ],\n    [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:1,dy:1} ],\n    [ {dx:0,dy:0}, {dx:-1,dy:0}, {dx:-1,dy:1} ],\n    [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:-1,dy:1} ],\n    // T shapes (4 rotations)\n    [ {dx:0,dy:0}, {dx:-1,dy:1}, {dx:0,dy:1}, {dx:1,dy:1} ],\n    [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:1,dy:0}, {dx:0,dy:-1} ],\n    [ {dx:0,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:1,dy:0} ],\n    [ {dx:0,dy:0}, {dx:0,dy:-1}, {dx:-1,dy:0}, {dx:0,dy:1} ],\n  ];\n  let wallCellsPlaced = 0;\n  while (wallCellsPlaced < NUM_WALLS) {\n    // Randomly pick a shape\n    const shape = wallShapes[Math.floor(Math.random() * wallShapes.length)];\n    // Randomly pick a starting cell\n    const x0 = Math.floor(Math.random() * BOARD_SIZE);\n    const y0 = Math.floor(Math.random() * BOARD_SIZE);\n    // Compute all cells for this shape\n    const shapeCells = shape.map(({dx,dy}) => ({x: x0+dx, y: y0+dy}));\n    // Check all in bounds and not forbidden/occupied\n    if (shapeCells.every(({x,y}) => x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && !occupied.has(`${x},${y}`) && !forbidden.has(`${x},${y}`))) {\n      shapeCells.forEach(({x,y}) => {\n        wallPositions.push({x,y});\n        forbidden.add(`${x},${y}`);\n        occupied.add(`${x},${y}`);\n        wallCellsPlaced++;\n      });\n    }\n    // Prevent infinite loop if board is too full\n    if (wallCellsPlaced > BOARD_SIZE*BOARD_SIZE*0.5) break;\n  }\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(agentPos, forbidden);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(wumpusPos, forbidden);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(goldPos, forbidden, true); // skipCenter=true: do not forbid the gold cell itself\n  // Place bats\n  const batPositions = [];\n  for (let i = 0; i < NUM_BATS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    batPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n  // Place pits\n  const pitPositions = [];\n  for (let i = 0; i < NUM_PITS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    pitPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n\n  // Build board\n  const board: Cell[][] = Array.from({ length: BOARD_SIZE }, (_, y) =>\n    Array.from({ length: BOARD_SIZE }, (_, x) => {\n      if (wallPositions.some(w => w.x === x && w.y === y)) return { type: 'wall', explored: false };\n      return { type: 'empty', explored: false };\n    })\n  );\n  board[wumpusPos.y][wumpusPos.x] = { type: 'wumpus', explored: false };\n  batPositions.forEach(({ x, y }) => (board[y][x] = { type: 'bat', explored: false }));\n  pitPositions.forEach(({ x, y }) => (board[y][x] = { type: 'pit', explored: false }));\n  // Place gold last so it is never overwritten\n  board[goldPos.y][goldPos.x] = { type: 'gold', explored: false };\n\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    actionLog: [\n      `Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`,\n      `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`,\n      `Gold at (${goldPos.x + 1},${goldPos.y + 1})`,\n    ],\n    agentState: createAgentState(agentPos),\n    // Ensure hasGold is always false at game start\n    hasGold: false,\n  } as GameState;\n}\n\nexport function createAgentState(agentPos: { x: number; y: number }): AgentState {\n  return {\n    stack: [agentPos],\n    visited: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true,\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [\n  { dx: 0, dy: -1 },  // up\n  { dx: 1, dy: 0 },   // right\n  { dx: 0, dy: 1 },   // down\n  { dx: -1, dy: 0 },  // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x: number, y: number) {\n  const dirs = shuffle([...DIRS]);\n  return dirs\n    .map(({ dx, dy }) => ({ x: x + dx, y: y + dy }))\n    .filter(({ x, y }) => isValid(x, y));\n}\n\nfunction isValid(x: number, y: number) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game: GameState, x: number, y: number) {\n  let dangerLevel = 0;\n  let adjWumpus: { x: number; y: number } | null = null;\n  let adjBats = 0, adjPits = 0;\n  for (const { x: nx, y: ny } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = { x: nx, y: ny };\n    } else if (t === 'pit') {\n      dangerLevel += 10;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return { dangerLevel, adjWumpus, adjBats, adjPits };\n}\n\nexport function agentStep(game: GameState): GameState {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n\n  // INSTANT WIN: If agent is on the gold position, win immediately\n  if (game.agentPos.x === game.goldPos.x && game.agentPos.y === game.goldPos.y && !agent.hasGold) {\n    let log = game.actionLog ? [...game.actionLog] : [];\n    agent.hasGold = true;\n    log.push(`[GOLD] Agent found the gold! WON! (at ${game.agentPos.x + 1},${game.agentPos.y + 1})`);\n    return { ...game, status: 'won', actionLog: log };\n  }\n\n  // Get current position from top of stack (DFS path)\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // Do not mark wall cells as visited/explored, and treat as stuck if agent is on a wall (defensive)\n  const currCell = game.board[curr.y][curr.x];\n  if (currCell.type === 'wall') {\n    log.push('Agent is stuck on a wall cell. This should not happen.');\n    return { ...game, status: 'lost', actionLog: log };\n  }\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = { x: curr.x, y: curr.y };\n  // Log visited cells for debugging\n  const visitedCells = [];\n  for (let y = 0; y < BOARD_SIZE; y++) {\n    for (let x = 0; x < BOARD_SIZE; x++) {\n      if (agent.visited[y][x]) visitedCells.push(`(${x + 1},${y + 1})`);\n    }\n  }\n  \n\n  // Sensory warnings for current cell (before any action)\n  let sensedWumpus = false, sensedPit = false, sensedBat = false;\n  for (const n of getAdjacent(curr.x, curr.y)) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus = true;\n    if (t === 'pit') sensedPit = true;\n    if (t === 'bat') sensedBat = true;\n  }\n  if (sensedWumpus) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // Check for threats at current cell\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'gold' && !agent.hasGold) {\n    agent.hasGold = true;\n    log.push(`Agent found the gold! WON! (at ${curr.x + 1},${curr.y + 1})`);\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'won', actionLog: log };\n  }\n  if (cell.type === 'pit') {\n    log.push(`Agent fell into a pit at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'wumpus') {\n    log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty: { x: number; y: number }[] = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++)\n      if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({ x, y });\n    // Exclude wall cells from teleport destinations\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) {\n      if (game.board[y][x].type === 'wall') {\n        // Remove any wall cell from empty[] if present\n        const idx = empty.findIndex(pos => pos.x === x && pos.y === y);\n        if (idx !== -1) empty.splice(idx, 1);\n      }\n    }\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = { x: empty[idx].x, y: empty[idx].y };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push(`Agent found the gold! WON! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'won', actionLog: log };\n      }\n      if (newCell.type === 'pit') {\n        log.push(`Agent fell into a pit at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n        return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n      }\n      return { ...game, actionLog: log };\n    }\n  }\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible ---\n  const neighbors = getAdjacent(curr.x, curr.y);\n  let shot = false;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return { ...game, status: 'won', actionLog: log };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      shot = true;\n      break; // Only shoot once per step\n    }\n  }\n  // If adjacent to Wumpus but no arrows, just continue exploring\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus2 = false, sensedPit2 = false, sensedBat2 = false;\n  for (const n of neighbors) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus2 = true;\n    if (t === 'pit') sensedPit2 = true;\n    if (t === 'bat') sensedBat2 = true;\n  }\n  if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit2) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat2) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor: { x: number; y: number } | null = null;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    // Use a special marker for gold messages instead of HTML for console compatibility\n    log.push(`[GOLD] You are lucky, gold is near! (at ${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // --- DFS MOVEMENT: Choose next move ---\n  let moved = false;\n  // If gold is adjacent and unvisited and not a wall, move to it immediately\n  if (goldNeighbor && !agent.visited[goldNeighbor.y][goldNeighbor.x] && game.board[goldNeighbor.y][goldNeighbor.x].type !== 'wall') {\n    agent.stack.push(goldNeighbor);\n    moved = true;\n  } else {\n    // Prefer unvisited, non-wall neighbor if gold is not adjacent or already visited\n    for (const n of neighbors) {\n      if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type !== 'wall') {\n        agent.stack.push(n);\n        moved = true;\n        break;\n      }\n    }\n  }\n  // If still no move, backtrack\n  if (!moved) {\n    agent.stack.pop();\n  }\n  // Only mark as visited and log for the cell the agent actually moves to\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    // Only mark as visited if the agent is actually moving to this cell now and it's not a wall\n    if ((game.agentPos.x !== pos.x || game.agentPos.y !== pos.y) && game.board[pos.y][pos.x].type !== 'wall') {\n      agent.visited[pos.y][pos.x] = true;\n      game.explored[pos.y][pos.x] = true;\n    }\n    game.agentPos = { x: pos.x, y: pos.y };\n    // Sensory warnings for new cell (after move)\n    let sensedWumpus2 = false, sensedPit2 = false, sensedBat2 = false;\n    for (const n of neighbors) {\n      const t = game.board[n.y][n.x].type;\n      if (t === 'wumpus') sensedWumpus2 = true;\n      if (t === 'pit') sensedPit2 = true;\n      if (t === 'bat') sensedBat2 = true;\n    }\n    if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedPit2) log.push(`You feel a breeze nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedBat2) log.push(`You hear flapping nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push(`[GOLD] You are lucky, gold is near! (at ${pos.x + 1},${pos.y + 1})`);\n    }\n    // Always check for gold/pit/wumpus at the new cell, even if already visited\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold' && !agent.hasGold) {\n      agent.hasGold = true;\n      log.push(`[GOLD] Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent tried to move into a wall cell. This should not happen.');\n      return { ...game, status: 'lost', actionLog: log };\n    }\n  } else {\n    // If stack is empty, check for win/loss at current position as well\n    const pos = game.agentPos;\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold' && !agent.hasGold) {\n      agent.hasGold = true;\n      log.push(`[GOLD] Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent is stuck on a wall cell. This should not happen.');\n      return { ...game, status: 'lost', actionLog: log };\n    }\n    log.push('No moves left. Agent is stuck.');\n    return { ...game, status: 'lost', actionLog: log };\n  }\n  return { ...game, actionLog: log };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}