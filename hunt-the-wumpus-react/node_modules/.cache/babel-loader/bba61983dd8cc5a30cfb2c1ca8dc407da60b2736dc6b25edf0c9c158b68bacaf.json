{"ast":null,"code":"const BOARD_SIZE = 20;\nconst NUM_BATS = 8;\nconst NUM_PITS = 4;\nfunction getRandomEmptyCell(occupied) {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return {\n    x,\n    y\n  };\n}\nexport function createNewGame() {\n  const occupied = new Set();\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied);\n  // Place bats\n  const batPositions = Array.from({\n    length: NUM_BATS\n  }, () => getRandomEmptyCell(occupied));\n  // Place pits\n  const pitPositions = Array.from({\n    length: NUM_PITS\n  }, () => getRandomEmptyCell(occupied));\n\n  // Build board\n  const board = Array.from({\n    length: BOARD_SIZE\n  }, (_, y) => Array.from({\n    length: BOARD_SIZE\n  }, (_, x) => ({\n    type: 'empty',\n    explored: false\n  })));\n  board[agentPos.y][agentPos.x] = {\n    type: 'agent',\n    explored: true\n  };\n  board[wumpusPos.y][wumpusPos.x] = {\n    type: 'wumpus',\n    explored: false\n  };\n  board[goldPos.y][goldPos.x] = {\n    type: 'gold',\n    explored: false\n  };\n  batPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'bat',\n    explored: false\n  });\n  pitPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'pit',\n    explored: false\n  });\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    stats: {\n      games: 1,\n      victories: 0\n    }\n  };\n}\nexport function createAgentState(agentPos) {\n  return {\n    stack: [agentPos],\n    visited: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [{\n  dx: 0,\n  dy: -1\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: -1,\n  dy: 0\n}];\nfunction isValid(x, y) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: get adjacent cells\nfunction getAdjacent(x, y) {\n  return DIRS.map(({\n    dx,\n    dy\n  }) => ({\n    x: x + dx,\n    y: y + dy\n  })).filter(({\n    x,\n    y\n  }) => isValid(x, y));\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game, x, y) {\n  let dangerLevel = 0;\n  let adjWumpus = null;\n  let adjBats = 0,\n    adjPits = 0;\n  for (const {\n    x: nx,\n    y: ny\n  } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = {\n        x: nx,\n        y: ny\n      };\n    } else if (t === 'pit') {\n      dangerLevel += 20;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return {\n    dangerLevel,\n    adjWumpus,\n    adjBats,\n    adjPits\n  };\n}\nexport function agentStep(game) {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n  if (agent.stack.length === 0) return {\n    ...game,\n    status: 'lost'\n  };\n  const curr = agent.stack[agent.stack.length - 1];\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n\n  // Check for gold\n  if (curr.x === game.goldPos.x && curr.y === game.goldPos.y && !agent.hasGold) {\n    agent.hasGold = true;\n    return {\n      ...game,\n      status: 'won'\n    };\n  }\n  // Check for threats (pit, wumpus, bat)\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'pit' || cell.type === 'wumpus') {\n    return {\n      ...game,\n      status: 'lost'\n    };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited\n    const empty = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({\n      x,\n      y\n    });\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      agent.path.push(empty[idx]);\n      // Optionally: reset visited? (Python: only stack/explored, not dangers)\n      return {\n        ...game\n      };\n    }\n  }\n  // Detect adjacent threats\n  const {\n    dangerLevel,\n    adjWumpus\n  } = detectThreats(game, curr.x, curr.y);\n  if (dangerLevel > 0) {\n    // Mark as dangerous\n    // (In a full implementation, keep a danger map; for now, just backtrack or shoot)\n    if (dangerLevel >= 50 && adjWumpus && agent.arrows > 0) {\n      // Try to shoot\n      agent.arrows--;\n      // 50% chance to hit (or always hit if adjacent)\n      if (Math.random() < 0.5 || adjWumpus.x === curr.x || adjWumpus.y === curr.y) {\n        // Remove wumpus\n        game.board[adjWumpus.y][adjWumpus.x].type = 'empty';\n        return {\n          ...game\n        };\n      } else {\n        // Miss: backtrack\n        agent.stack.pop();\n        return {\n          ...game\n        };\n      }\n    } else if (dangerLevel > 10) {\n      // Backtrack\n      agent.stack.pop();\n      return {\n        ...game\n      };\n    } // else, bats: continue but avoid in future\n  }\n  // DFS: explore unexplored, non-dangerous neighbors\n  const neighbors = getAdjacent(curr.x, curr.y);\n  for (const n of neighbors) {\n    if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type === 'empty') {\n      agent.stack.push(n);\n      agent.path.push(n);\n      return {\n        ...game\n      };\n    }\n  }\n  // If all explored, backtrack\n  agent.stack.pop();\n  return {\n    ...game\n  };\n}","map":{"version":3,"names":["BOARD_SIZE","NUM_BATS","NUM_PITS","getRandomEmptyCell","occupied","x","y","Math","floor","random","has","add","createNewGame","Set","agentPos","wumpusPos","goldPos","batPositions","Array","from","length","pitPositions","board","_","type","explored","forEach","fill","status","stats","games","victories","createAgentState","stack","visited","arrows","hasGold","path","autoMode","DIRS","dx","dy","isValid","getAdjacent","map","filter","detectThreats","game","dangerLevel","adjWumpus","adjBats","adjPits","nx","ny","t","agentStep","agentState","agent","curr","cell","empty","push","idx","pop","neighbors","n"],"sources":["/workspaces/HuntTheWumpus/hunt-the-wumpus-react/src/utils/gameLogic.ts"],"sourcesContent":["import { GameState, Cell, CellType, AgentState } from './gameTypes';\n\nconst BOARD_SIZE = 20;\nconst NUM_BATS = 8;\nconst NUM_PITS = 4;\n\nfunction getRandomEmptyCell(occupied: Set<string>): { x: number; y: number } {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return { x, y };\n}\n\nexport function createNewGame(): GameState {\n  const occupied = new Set<string>();\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied);\n  // Place bats\n  const batPositions = Array.from({ length: NUM_BATS }, () => getRandomEmptyCell(occupied));\n  // Place pits\n  const pitPositions = Array.from({ length: NUM_PITS }, () => getRandomEmptyCell(occupied));\n\n  // Build board\n  const board: Cell[][] = Array.from({ length: BOARD_SIZE }, (_, y) =>\n    Array.from({ length: BOARD_SIZE }, (_, x) => ({ type: 'empty', explored: false }))\n  );\n  board[agentPos.y][agentPos.x] = { type: 'agent', explored: true };\n  board[wumpusPos.y][wumpusPos.x] = { type: 'wumpus', explored: false };\n  board[goldPos.y][goldPos.x] = { type: 'gold', explored: false };\n  batPositions.forEach(({ x, y }) => (board[y][x] = { type: 'bat', explored: false }));\n  pitPositions.forEach(({ x, y }) => (board[y][x] = { type: 'pit', explored: false }));\n\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    stats: { games: 1, victories: 0 },\n  };\n}\n\nexport function createAgentState(agentPos: { x: number; y: number }): AgentState {\n  return {\n    stack: [agentPos],\n    visited: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true,\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [\n  { dx: 0, dy: -1 },\n  { dx: 1, dy: 0 },\n  { dx: 0, dy: 1 },\n  { dx: -1, dy: 0 },\n];\n\nfunction isValid(x: number, y: number) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: get adjacent cells\nfunction getAdjacent(x: number, y: number) {\n  return DIRS\n    .map(({ dx, dy }) => ({ x: x + dx, y: y + dy }))\n    .filter(({ x, y }) => isValid(x, y));\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game: GameState, x: number, y: number) {\n  let dangerLevel = 0;\n  let adjWumpus: { x: number; y: number } | null = null;\n  let adjBats = 0, adjPits = 0;\n  for (const { x: nx, y: ny } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = { x: nx, y: ny };\n    } else if (t === 'pit') {\n      dangerLevel += 20;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return { dangerLevel, adjWumpus, adjBats, adjPits };\n}\n\nexport function agentStep(game: GameState): GameState {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n  if (agent.stack.length === 0) return { ...game, status: 'lost' };\n  const curr = agent.stack[agent.stack.length - 1];\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n\n  // Check for gold\n  if (curr.x === game.goldPos.x && curr.y === game.goldPos.y && !agent.hasGold) {\n    agent.hasGold = true;\n    return { ...game, status: 'won' };\n  }\n  // Check for threats (pit, wumpus, bat)\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'pit' || cell.type === 'wumpus') {\n    return { ...game, status: 'lost' };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited\n    const empty: { x: number; y: number }[] = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++)\n      if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({ x, y });\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      agent.path.push(empty[idx]);\n      // Optionally: reset visited? (Python: only stack/explored, not dangers)\n      return { ...game };\n    }\n  }\n  // Detect adjacent threats\n  const { dangerLevel, adjWumpus } = detectThreats(game, curr.x, curr.y);\n  if (dangerLevel > 0) {\n    // Mark as dangerous\n    // (In a full implementation, keep a danger map; for now, just backtrack or shoot)\n    if (dangerLevel >= 50 && adjWumpus && agent.arrows > 0) {\n      // Try to shoot\n      agent.arrows--;\n      // 50% chance to hit (or always hit if adjacent)\n      if (Math.random() < 0.5 || (adjWumpus.x === curr.x || adjWumpus.y === curr.y)) {\n        // Remove wumpus\n        game.board[adjWumpus.y][adjWumpus.x].type = 'empty';\n        return { ...game };\n      } else {\n        // Miss: backtrack\n        agent.stack.pop();\n        return { ...game };\n      }\n    } else if (dangerLevel > 10) {\n      // Backtrack\n      agent.stack.pop();\n      return { ...game };\n    } // else, bats: continue but avoid in future\n  }\n  // DFS: explore unexplored, non-dangerous neighbors\n  const neighbors = getAdjacent(curr.x, curr.y);\n  for (const n of neighbors) {\n    if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type === 'empty') {\n      agent.stack.push(n);\n      agent.path.push(n);\n      return { ...game };\n    }\n  }\n  // If all explored, backtrack\n  agent.stack.pop();\n  return { ...game };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}