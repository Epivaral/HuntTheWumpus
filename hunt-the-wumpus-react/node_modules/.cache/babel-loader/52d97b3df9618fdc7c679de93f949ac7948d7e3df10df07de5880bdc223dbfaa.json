{"ast":null,"code":"const BOARD_SIZE = 20;\nconst NUM_BATS = 8;\nconst NUM_PITS = 4;\nfunction getRandomEmptyCell(occupied) {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return {\n    x,\n    y\n  };\n}\nexport function createNewGame(stats) {\n  const occupied = new Set();\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied);\n  // Place bats\n  const batPositions = Array.from({\n    length: NUM_BATS\n  }, () => getRandomEmptyCell(occupied));\n  // Place pits\n  const pitPositions = Array.from({\n    length: NUM_PITS\n  }, () => getRandomEmptyCell(occupied));\n\n  // Build board\n  const board = Array.from({\n    length: BOARD_SIZE\n  }, (_, y) => Array.from({\n    length: BOARD_SIZE\n  }, (_, x) => ({\n    type: 'empty',\n    explored: false\n  })));\n  board[wumpusPos.y][wumpusPos.x] = {\n    type: 'wumpus',\n    explored: false\n  };\n  board[goldPos.y][goldPos.x] = {\n    type: 'gold',\n    explored: false\n  };\n  batPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'bat',\n    explored: false\n  });\n  pitPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'pit',\n    explored: false\n  });\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    actionLog: [`Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`, `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`, `Gold at (${goldPos.x + 1},${goldPos.y + 1})`],\n    agentState: createAgentState(agentPos),\n    // Ensure hasGold is always false at game start\n    hasGold: false\n  };\n}\nexport function createAgentState(agentPos) {\n  return {\n    stack: [agentPos],\n    visited: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [{\n  dx: 0,\n  dy: -1\n},\n// up\n{\n  dx: 1,\n  dy: 0\n},\n// right\n{\n  dx: 0,\n  dy: 1\n},\n// down\n{\n  dx: -1,\n  dy: 0\n} // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x, y) {\n  const dirs = shuffle([...DIRS]);\n  return dirs.map(({\n    dx,\n    dy\n  }) => ({\n    x: x + dx,\n    y: y + dy\n  })).filter(({\n    x,\n    y\n  }) => isValid(x, y));\n}\nfunction isValid(x, y) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game, x, y) {\n  let dangerLevel = 0;\n  let adjWumpus = null;\n  let adjBats = 0,\n    adjPits = 0;\n  for (const {\n    x: nx,\n    y: ny\n  } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = {\n        x: nx,\n        y: ny\n      };\n    } else if (t === 'pit') {\n      dangerLevel += 10;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return {\n    dangerLevel,\n    adjWumpus,\n    adjBats,\n    adjPits\n  };\n}\nexport function agentStep(game) {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n\n  // Get current position from top of stack (DFS path)\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // Mark current as visited\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = {\n    x: curr.x,\n    y: curr.y\n  };\n  log.push(`Agent moved to (${curr.x + 1},${curr.y + 1})`);\n\n  // Check for threats at current cell\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'gold' && !agent.hasGold) {\n    agent.hasGold = true;\n    log.push('Agent found the gold! WON!');\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'won',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'pit') {\n    log.push('Agent fell into a pit at this cell. Lost!');\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'wumpus') {\n    log.push('Agent encountered the Wumpus at this cell. Lost!');\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({\n      x,\n      y\n    });\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = {\n        x: empty[idx].x,\n        y: empty[idx].y\n      };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push('Agent found the gold! WON!');\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'pit') {\n        log.push('Agent fell into a pit at this cell. Lost!');\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push('Agent encountered the Wumpus at this cell. Lost!');\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push('Agent found the gold! WON!');\n        return {\n          ...game,\n          agentPos: {\n            x: pos.x,\n            y: pos.y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible ---\n  const neighbors = getAdjacent(curr.x, curr.y);\n  let shot = false;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return {\n          ...game,\n          status: 'won',\n          actionLog: log\n        };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      shot = true;\n      break; // Only shoot once per step\n    }\n  }\n  // If adjacent to Wumpus but no arrows, just continue exploring\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus = false,\n    sensedPit = false,\n    sensedBat = false;\n  for (const n of neighbors) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus = true;\n    if (t === 'pit') sensedPit = true;\n    if (t === 'bat') sensedBat = true;\n  }\n  if (sensedWumpus) log.push('You smell something terrible nearby.');\n  if (sensedPit) log.push('You feel a breeze nearby.');\n  if (sensedBat) log.push('You hear flapping nearby.');\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor = null;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    log.push('You are lucky, gold is near!');\n  }\n\n  // --- DFS MOVEMENT: Choose next move ---\n  let moved = false;\n  let nextPos = null;\n  // Prefer unvisited neighbor if gold is adjacent (will check after move)\n  for (const n of neighbors) {\n    if (!agent.visited[n.y][n.x]) {\n      agent.stack.push(n);\n      moved = true;\n      break;\n    }\n  }\n  // If still no move, backtrack\n  if (!moved) {\n    agent.stack.pop();\n  }\n  // Always move to the top of the stack (if any)\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    agent.visited[pos.y][pos.x] = true;\n    game.explored[pos.y][pos.x] = true;\n    game.agentPos = {\n      x: pos.x,\n      y: pos.y\n    };\n    log.push(`Agent moved to (${pos.x + 1},${pos.y + 1})`);\n    log.push(`DEBUG: Cell type at (${pos.x + 1},${pos.y + 1}) is '${game.board[pos.y][pos.x].type}'`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push('You are lucky, gold is near!');\n    }\n    // Check for gold/pit/wumpus at the new cell\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold' && !agent.hasGold) {\n      agent.hasGold = true;\n      log.push('Agent found the gold! WON!');\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'won',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'pit') {\n      log.push('Agent fell into a pit at this cell. Lost!');\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wumpus') {\n      log.push('Agent encountered the Wumpus at this cell. Lost!');\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n  } else {\n    log.push('No moves left. Agent is stuck.');\n    return {\n      ...game,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  return {\n    ...game,\n    actionLog: log\n  };\n}","map":{"version":3,"names":["BOARD_SIZE","NUM_BATS","NUM_PITS","getRandomEmptyCell","occupied","x","y","Math","floor","random","has","add","createNewGame","stats","Set","agentPos","wumpusPos","goldPos","batPositions","Array","from","length","pitPositions","board","_","type","explored","forEach","fill","status","actionLog","agentState","createAgentState","hasGold","stack","visited","arrows","path","autoMode","DIRS","dx","dy","shuffle","array","i","j","getAdjacent","dirs","map","filter","isValid","detectThreats","game","dangerLevel","adjWumpus","adjBats","adjPits","nx","ny","t","agentStep","agent","curr","log","push","cell","empty","idx","newCell","pos","neighbors","shot","n","sensedWumpus","sensedPit","sensedBat","goldNearby","goldNeighbor","moved","nextPos","pop","goldNear","some"],"sources":["/workspaces/HuntTheWumpus/hunt-the-wumpus-react/src/utils/gameLogic.ts"],"sourcesContent":["import { GameState, Cell, CellType, AgentState } from './gameTypes';\n\nconst BOARD_SIZE = 20;\nconst NUM_BATS = 8;\nconst NUM_PITS = 4;\n\nfunction getRandomEmptyCell(occupied: Set<string>): { x: number; y: number } {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return { x, y };\n}\n\nexport function createNewGame(stats: { games: number; victories: number }): GameState {\n  const occupied = new Set<string>();\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied);\n  // Place bats\n  const batPositions = Array.from({ length: NUM_BATS }, () => getRandomEmptyCell(occupied));\n  // Place pits\n  const pitPositions = Array.from({ length: NUM_PITS }, () => getRandomEmptyCell(occupied));\n\n  // Build board\n  const board: Cell[][] = Array.from({ length: BOARD_SIZE }, (_, y) =>\n    Array.from({ length: BOARD_SIZE }, (_, x) => ({ type: 'empty', explored: false }))\n  );\n  board[wumpusPos.y][wumpusPos.x] = { type: 'wumpus', explored: false };\n  board[goldPos.y][goldPos.x] = { type: 'gold', explored: false };\n  batPositions.forEach(({ x, y }) => (board[y][x] = { type: 'bat', explored: false }));\n  pitPositions.forEach(({ x, y }) => (board[y][x] = { type: 'pit', explored: false }));\n\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    actionLog: [\n      `Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`,\n      `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`,\n      `Gold at (${goldPos.x + 1},${goldPos.y + 1})`,\n    ],\n    agentState: createAgentState(agentPos),\n    // Ensure hasGold is always false at game start\n    hasGold: false,\n  } as GameState;\n}\n\nexport function createAgentState(agentPos: { x: number; y: number }): AgentState {\n  return {\n    stack: [agentPos],\n    visited: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true,\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [\n  { dx: 0, dy: -1 },  // up\n  { dx: 1, dy: 0 },   // right\n  { dx: 0, dy: 1 },   // down\n  { dx: -1, dy: 0 },  // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x: number, y: number) {\n  const dirs = shuffle([...DIRS]);\n  return dirs\n    .map(({ dx, dy }) => ({ x: x + dx, y: y + dy }))\n    .filter(({ x, y }) => isValid(x, y));\n}\n\nfunction isValid(x: number, y: number) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game: GameState, x: number, y: number) {\n  let dangerLevel = 0;\n  let adjWumpus: { x: number; y: number } | null = null;\n  let adjBats = 0, adjPits = 0;\n  for (const { x: nx, y: ny } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = { x: nx, y: ny };\n    } else if (t === 'pit') {\n      dangerLevel += 10;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return { dangerLevel, adjWumpus, adjBats, adjPits };\n}\n\nexport function agentStep(game: GameState): GameState {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n\n  // Get current position from top of stack (DFS path)\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // Mark current as visited\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = { x: curr.x, y: curr.y };\n  log.push(`Agent moved to (${curr.x + 1},${curr.y + 1})`);\n\n  // Check for threats at current cell\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'gold' && !agent.hasGold) {\n    agent.hasGold = true;\n    log.push('Agent found the gold! WON!');\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'won', actionLog: log };\n  }\n  if (cell.type === 'pit') {\n    log.push('Agent fell into a pit at this cell. Lost!');\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'wumpus') {\n    log.push('Agent encountered the Wumpus at this cell. Lost!');\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty: { x: number; y: number }[] = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++)\n      if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({ x, y });\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = { x: empty[idx].x, y: empty[idx].y };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push('Agent found the gold! WON!');\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'won', actionLog: log };\n      }\n      if (newCell.type === 'pit') {\n        log.push('Agent fell into a pit at this cell. Lost!');\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push('Agent encountered the Wumpus at this cell. Lost!');\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push('Agent found the gold! WON!');\n        return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n      }\n      return { ...game, actionLog: log };\n    }\n  }\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible ---\n  const neighbors = getAdjacent(curr.x, curr.y);\n  let shot = false;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return { ...game, status: 'won', actionLog: log };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      shot = true;\n      break; // Only shoot once per step\n    }\n  }\n  // If adjacent to Wumpus but no arrows, just continue exploring\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus = false, sensedPit = false, sensedBat = false;\n  for (const n of neighbors) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus = true;\n    if (t === 'pit') sensedPit = true;\n    if (t === 'bat') sensedBat = true;\n  }\n  if (sensedWumpus) log.push('You smell something terrible nearby.');\n  if (sensedPit) log.push('You feel a breeze nearby.');\n  if (sensedBat) log.push('You hear flapping nearby.');\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor: { x: number; y: number } | null = null;\n  for (const n of neighbors) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    log.push('You are lucky, gold is near!');\n  }\n\n  // --- DFS MOVEMENT: Choose next move ---\n  let moved = false;\n  let nextPos = null;\n  // Prefer unvisited neighbor if gold is adjacent (will check after move)\n  for (const n of neighbors) {\n    if (!agent.visited[n.y][n.x]) {\n      agent.stack.push(n);\n      moved = true;\n      break;\n    }\n  }\n  // If still no move, backtrack\n  if (!moved) {\n    agent.stack.pop();\n  }\n  // Always move to the top of the stack (if any)\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    agent.visited[pos.y][pos.x] = true;\n    game.explored[pos.y][pos.x] = true;\n    game.agentPos = { x: pos.x, y: pos.y };\n    log.push(`Agent moved to (${pos.x + 1},${pos.y + 1})`);\n    log.push(`DEBUG: Cell type at (${pos.x + 1},${pos.y + 1}) is '${game.board[pos.y][pos.x].type}'`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push('You are lucky, gold is near!');\n    }\n    // Check for gold/pit/wumpus at the new cell\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold' && !agent.hasGold) {\n      agent.hasGold = true;\n      log.push('Agent found the gold! WON!');\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n    }\n    if (cell.type === 'pit') {\n      log.push('Agent fell into a pit at this cell. Lost!');\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wumpus') {\n      log.push('Agent encountered the Wumpus at this cell. Lost!');\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n  } else {\n    log.push('No moves left. Agent is stuck.');\n    return { ...game, status: 'lost', actionLog: log };\n  }\n  return { ...game, actionLog: log };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}