{"ast":null,"code":"const BOARD_SIZE = 20;\nconst NUM_BATS = 6;\nconst NUM_PITS = 3;\n\n// Predefined wall cluster shapes (all size 5, all rotations)\nconst WALL_SHAPES_5 = [\n// I shapes\n[{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 0,\n  dy: 2\n}, {\n  dx: 0,\n  dy: 3\n}, {\n  dx: 0,\n  dy: 4\n}],\n// vertical\n[{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 2,\n  dy: 0\n}, {\n  dx: 3,\n  dy: 0\n}, {\n  dx: 4,\n  dy: 0\n}],\n// horizontal\n// L shapes\n[{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 2,\n  dy: 0\n}, {\n  dx: 2,\n  dy: 1\n}, {\n  dx: 2,\n  dy: 2\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 0,\n  dy: 2\n}, {\n  dx: 1,\n  dy: 2\n}, {\n  dx: 2,\n  dy: 2\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: -1,\n  dy: 0\n}, {\n  dx: -2,\n  dy: 0\n}, {\n  dx: -2,\n  dy: 1\n}, {\n  dx: -2,\n  dy: 2\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: -1\n}, {\n  dx: 0,\n  dy: -2\n}, {\n  dx: 1,\n  dy: -2\n}, {\n  dx: 2,\n  dy: -2\n}],\n// T shapes\n[{\n  dx: 0,\n  dy: 0\n}, {\n  dx: -1,\n  dy: 1\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 1,\n  dy: 1\n}, {\n  dx: 0,\n  dy: 2\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 0,\n  dy: -1\n}, {\n  dx: -1,\n  dy: 0\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: -1,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 0,\n  dy: -1\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: -1\n}, {\n  dx: -1,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 1,\n  dy: 0\n}],\n// U shapes\n[{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 0,\n  dy: 2\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 1,\n  dy: 2\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 2,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 2,\n  dy: 1\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 0,\n  dy: 2\n}, {\n  dx: -1,\n  dy: 0\n}, {\n  dx: -1,\n  dy: 2\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: -1,\n  dy: 0\n}, {\n  dx: -2,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: -2,\n  dy: 1\n}],\n// Plus shape\n[{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: 0,\n  dy: -1\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: -1,\n  dy: 0\n}],\n// Zigzag\n[{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 1,\n  dy: 0\n}, {\n  dx: 1,\n  dy: 1\n}, {\n  dx: 2,\n  dy: 1\n}, {\n  dx: 2,\n  dy: 2\n}], [{\n  dx: 0,\n  dy: 0\n}, {\n  dx: 0,\n  dy: 1\n}, {\n  dx: -1,\n  dy: 1\n}, {\n  dx: -1,\n  dy: 2\n}, {\n  dx: -2,\n  dy: 2\n}]];\nfunction getRandomEmptyCell(occupied, forbidden = new Set()) {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`) || forbidden.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return {\n    x,\n    y\n  };\n}\nfunction randomWallCluster(start, occupied, forbidden, minSize = 5, maxSize = 15) {\n  const cluster = [start];\n  const seen = new Set([`${start.x},${start.y}`]);\n  let frontier = [start];\n  while (cluster.length < maxSize && frontier.length > 0) {\n    const nextFrontier = [];\n    for (const cell of frontier) {\n      const adj = [{\n        x: cell.x + 1,\n        y: cell.y\n      }, {\n        x: cell.x - 1,\n        y: cell.y\n      }, {\n        x: cell.x,\n        y: cell.y + 1\n      }, {\n        x: cell.x,\n        y: cell.y - 1\n      }];\n      for (const n of adj) {\n        if (n.x >= 0 && n.x < BOARD_SIZE && n.y >= 0 && n.y < BOARD_SIZE && !occupied.has(`${n.x},${n.y}`) && !forbidden.has(`${n.x},${n.y}`) && !seen.has(`${n.x},${n.y}`)) {\n          if (Math.random() < 0.7 || cluster.length < minSize) {\n            // bias to grow until minSize\n            cluster.push(n);\n            nextFrontier.push(n);\n            seen.add(`${n.x},${n.y}`);\n            if (cluster.length >= maxSize) break;\n          }\n        }\n      }\n      if (cluster.length >= maxSize) break;\n    }\n    frontier = nextFrontier;\n  }\n  return cluster.length >= minSize ? cluster : [];\n}\nfunction markForbiddenArea(center, forbidden, skipCenter = false) {\n  for (let dy = -3; dy <= 3; dy++) {\n    for (let dx = -3; dx <= 3; dx++) {\n      const x = center.x + dx;\n      const y = center.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        if (skipCenter && dx === 0 && dy === 0) continue;\n        forbidden.add(`${x},${y}`);\n      }\n    }\n  }\n}\nexport function createNewGame(stats) {\n  const occupied = new Set();\n  const forbidden = new Set();\n  // Place wall clusters (predefined shapes, all size 5)\n  const NUM_WALLS = Math.floor(BOARD_SIZE * BOARD_SIZE * 0.10); // 10% of the board\n  const wallPositions = [];\n  let wallCellsPlaced = 0;\n  while (wallCellsPlaced < NUM_WALLS) {\n    // Randomly pick a shape\n    const shape = WALL_SHAPES_5[Math.floor(Math.random() * WALL_SHAPES_5.length)];\n    // Randomly pick a starting cell\n    const x0 = Math.floor(Math.random() * BOARD_SIZE);\n    const y0 = Math.floor(Math.random() * BOARD_SIZE);\n    // Compute all cells for this shape\n    const shapeCells = shape.map(({\n      dx,\n      dy\n    }) => ({\n      x: x0 + dx,\n      y: y0 + dy\n    }));\n    // Check all in bounds and not forbidden/occupied\n    if (shapeCells.every(({\n      x,\n      y\n    }) => x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && !occupied.has(`${x},${y}`) && !forbidden.has(`${x},${y}`))) {\n      shapeCells.forEach(({\n        x,\n        y\n      }) => {\n        wallPositions.push({\n          x,\n          y\n        });\n        forbidden.add(`${x},${y}`);\n        occupied.add(`${x},${y}`);\n        wallCellsPlaced++;\n        if (wallCellsPlaced >= NUM_WALLS) return;\n      });\n    }\n    // Prevent infinite loop if board is too full\n    if (wallCellsPlaced > BOARD_SIZE * BOARD_SIZE * 0.5) break;\n  }\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(agentPos, forbidden);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(wumpusPos, forbidden);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(goldPos, forbidden, true); // skipCenter=true: do not forbid the gold cell itself\n  // Place bats\n  const batPositions = [];\n  for (let i = 0; i < NUM_BATS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    batPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n  // Place pits\n  const pitPositions = [];\n  for (let i = 0; i < NUM_PITS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    pitPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n\n  // Build board\n  const board = Array.from({\n    length: BOARD_SIZE\n  }, (_, y) => Array.from({\n    length: BOARD_SIZE\n  }, (_, x) => {\n    if (wallPositions.some(w => w.x === x && w.y === y)) return {\n      type: 'wall',\n      explored: false\n    };\n    return {\n      type: 'empty',\n      explored: false\n    };\n  }));\n  board[wumpusPos.y][wumpusPos.x] = {\n    type: 'wumpus',\n    explored: false\n  };\n  batPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'bat',\n    explored: false\n  });\n  pitPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'pit',\n    explored: false\n  });\n  // Place gold last so it is never overwritten\n  board[goldPos.y][goldPos.x] = {\n    type: 'gold',\n    explored: false\n  };\n\n  // Initialize revealed (fog) array\n  const revealed = Array.from({\n    length: BOARD_SIZE\n  }, () => Array(BOARD_SIZE).fill(false));\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      const x = agentPos.x + dx;\n      const y = agentPos.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        revealed[y][x] = true;\n      }\n    }\n  }\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    revealed,\n    // <-- add revealed to game state\n    status: 'playing',\n    actionLog: [`Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`, `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`, `Gold at (${goldPos.x + 1},${goldPos.y + 1})`],\n    agentState: createAgentState(agentPos)\n  };\n}\nexport function createAgentState(agentPos) {\n  return {\n    stack: [agentPos],\n    visited: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    path: [agentPos],\n    autoMode: true\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [{\n  dx: 0,\n  dy: -1\n},\n// up\n{\n  dx: 1,\n  dy: 0\n},\n// right\n{\n  dx: 0,\n  dy: 1\n},\n// down\n{\n  dx: -1,\n  dy: 0\n} // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x, y) {\n  const dirs = shuffle([...DIRS]);\n  return dirs.map(({\n    dx,\n    dy\n  }) => ({\n    x: x + dx,\n    y: y + dy\n  })).filter(({\n    x,\n    y\n  }) => isValid(x, y));\n}\nfunction isValid(x, y) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper to update the revealed (fog) array for the agent's visible area\nfunction revealVisibleArea(game) {\n  const {\n    agentPos,\n    revealed\n  } = game;\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      const x = agentPos.x + dx;\n      const y = agentPos.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        revealed[y][x] = true;\n      }\n    }\n  }\n}\nexport function agentStep(game) {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // --- DETAILED LOGGING: Log all checks performed at this cell ---\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  const currCell = game.board[curr.y][curr.x];\n  const checks = [];\n  if (currCell.type === 'gold') checks.push('gold');\n  if (currCell.type === 'pit') checks.push('pit');\n  if (currCell.type === 'wumpus') checks.push('wumpus');\n  if (currCell.type === 'bat') checks.push('bat');\n  if (currCell.type === 'wall') checks.push('wall');\n  // Always check for adjacent threats\n  const adj = getAdjacent(curr.x, curr.y);\n  const neighbors = getAdjacent(curr.x, curr.y); // <-- Fix: define neighbors for DFS and sensory logic\n  if (adj.some(n => game.board[n.y][n.x].type === 'wumpus')) checks.push('adjacent wumpus');\n  if (adj.some(n => game.board[n.y][n.x].type === 'pit')) checks.push('adjacent pit');\n  if (adj.some(n => game.board[n.y][n.x].type === 'bat')) checks.push('adjacent bat');\n  if (adj.some(n => game.board[n.y][n.x].type === 'gold')) checks.push('adjacent gold');\n  if (adj.some(n => game.board[n.y][n.x].type === 'wall')) checks.push('adjacent wall');\n  log.push(`[LOG] Agent at (${curr.x + 1},${curr.y + 1}): checked for ${checks.length ? checks.join(', ') : 'nothing special'}`);\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible (ALWAYS do this before moving) ---\n  let shot = false;\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return {\n          ...game,\n          status: 'won',\n          actionLog: log\n        };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      shot = true;\n      break; // Only shoot once per step\n    }\n  }\n\n  // Helper to check instant win after any move\n  function checkGoldWin(g, a, logArr) {\n    if (g.agentPos.x === g.goldPos.x && g.agentPos.y === g.goldPos.y) {\n      logArr.push(`Agent found the gold! WON! (at ${g.agentPos.x + 1},${g.agentPos.y + 1})`);\n      return {\n        ...g,\n        status: 'won',\n        actionLog: logArr\n      };\n    }\n    return null;\n  }\n\n  // Check instant win at the start\n  const winStart = checkGoldWin(game, agent, log);\n  if (winStart) return winStart;\n\n  // Do not mark wall cells as visited/explored, and treat as stuck if agent is on a wall (defensive)\n  if (currCell.type === 'wall') {\n    log.push('Agent is stuck on a wall cell. This should not happen.');\n    return {\n      ...game,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = {\n    x: curr.x,\n    y: curr.y\n  };\n\n  // Always check for gold at the agent's current position after any move or backtrack\n  if (game.agentPos.x === game.goldPos.x && game.agentPos.y === game.goldPos.y) {\n    log.push(`Agent found the gold! WON! (at ${game.agentPos.x + 1},${game.agentPos.y + 1})`);\n    return {\n      ...game,\n      status: 'won',\n      actionLog: log\n    };\n  }\n\n  // Check for threats at current cell (remove duplicate gold win logic)\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'pit') {\n    log.push(`Agent fell into a pit at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'wumpus') {\n    log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({\n      x,\n      y\n    });\n    // Exclude wall cells from teleport destinations\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) {\n      if (game.board[y][x].type === 'wall') {\n        // Remove any wall cell from empty[] if present\n        const idx = empty.findIndex(pos => pos.x === x && pos.y === y);\n        if (idx !== -1) empty.splice(idx, 1);\n      }\n    }\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = {\n        x: empty[idx].x,\n        y: empty[idx].y\n      };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'pit') {\n        log.push(`Agent fell into a pit at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: pos.x,\n            y: pos.y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus2 = false,\n    sensedPit2 = false,\n    sensedBat2 = false;\n  for (const n of adj) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus2 = true;\n    if (t === 'pit') sensedPit2 = true;\n    if (t === 'bat') sensedBat2 = true;\n  }\n  if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit2) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat2) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor = null;\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    log.push(`You are lucky, gold is near! (at ${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // --- DFS MOVEMENT: Choose next move ---\n  let moved = false;\n  // If gold is adjacent and not a wall, move to it immediately (even if visited)\n  if (goldNeighbor && game.board[goldNeighbor.y][goldNeighbor.x].type !== 'wall') {\n    agent.stack.push(goldNeighbor);\n    moved = true;\n  } else {\n    // Prefer unvisited, non-wall neighbor if gold is not adjacent\n    for (const n of neighbors) {\n      if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type !== 'wall') {\n        agent.stack.push(n);\n        moved = true;\n        break;\n      }\n    }\n  }\n  // If still no move, backtrack\n  if (!moved) {\n    agent.stack.pop();\n  }\n  // Only mark as visited and log for the cell the agent actually moves to\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    // Only mark as visited if the agent is actually moving to this cell now and it's not a wall\n    if ((game.agentPos.x !== pos.x || game.agentPos.y !== pos.y) && game.board[pos.y][pos.x].type !== 'wall') {\n      agent.visited[pos.y][pos.x] = true;\n      game.explored[pos.y][pos.x] = true;\n    }\n    game.agentPos = {\n      x: pos.x,\n      y: pos.y\n    };\n    // Check instant win after agentPos update (including backtracking)\n    const winAfterStackMove = checkGoldWin(game, agent, log);\n    if (winAfterStackMove) return winAfterStackMove;\n    // Sensory warnings for new cell (after move)\n    let sensedWumpus2 = false,\n      sensedPit2 = false,\n      sensedBat2 = false;\n    for (const n of neighbors) {\n      const t = game.board[n.y][n.x].type;\n      if (t === 'wumpus') sensedWumpus2 = true;\n      if (t === 'pit') sensedPit2 = true;\n      if (t === 'bat') sensedBat2 = true;\n    }\n    if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedPit2) log.push(`You feel a breeze nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedBat2) log.push(`You hear flapping nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push(`You are lucky, gold is near! (at ${pos.x + 1},${pos.y + 1})`);\n    }\n    // Always check for gold/pit/wumpus at the new cell, even if already visited\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'won',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent tried to move into a wall cell. This should not happen.');\n      return {\n        ...game,\n        status: 'lost',\n        actionLog: log\n      };\n    }\n  } else {\n    // If stack is empty, check for win/loss at current position as well\n    const pos = game.agentPos;\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'won',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent is stuck on a wall cell. This should not happen.');\n      return {\n        ...game,\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    log.push('No moves left. Agent is stuck.');\n    return {\n      ...game,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  return {\n    ...game,\n    actionLog: log\n  };\n}\n\n// Agent step with algorithm selector: uses DFS or A* based on game.agentState.algorithm (default: DFS)\nexport function agentStepWithAlgorithm(game, algorithm) {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // --- DETAILED LOGGING: Log all checks performed at this cell ---\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  const currCell = game.board[curr.y][curr.x];\n  const checks = [];\n  if (currCell.type === 'gold') checks.push('gold');\n  if (currCell.type === 'pit') checks.push('pit');\n  if (currCell.type === 'wumpus') checks.push('wumpus');\n  if (currCell.type === 'bat') checks.push('bat');\n  if (currCell.type === 'wall') checks.push('wall');\n  // Always check for adjacent threats\n  const adj = getAdjacent(curr.x, curr.y);\n  if (adj.some(n => game.board[n.y][n.x].type === 'wumpus')) checks.push('adjacent wumpus');\n  if (adj.some(n => game.board[n.y][n.x].type === 'pit')) checks.push('adjacent pit');\n  if (adj.some(n => game.board[n.y][n.x].type === 'bat')) checks.push('adjacent bat');\n  if (adj.some(n => game.board[n.y][n.x].type === 'gold')) checks.push('adjacent gold');\n  if (adj.some(n => game.board[n.y][n.x].type === 'wall')) checks.push('adjacent wall');\n  log.push(`Agent at (${curr.x + 1},${curr.y + 1}): checked for ${checks.length ? checks.join(', ') : 'nothing special'}`);\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible (ALWAYS do this before moving) ---\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return {\n          ...game,\n          status: 'won',\n          actionLog: log\n        };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      break; // Only shoot once per step\n    }\n  }\n\n  // Helper to check instant win after any move\n  function checkGoldWin(g, a, logArr) {\n    if (g.agentPos.x === g.goldPos.x && g.agentPos.y === g.goldPos.y) {\n      logArr.push(`Agent found the gold! WON! (at ${g.agentPos.x + 1},${g.agentPos.y + 1})`);\n      return {\n        ...g,\n        status: 'won',\n        actionLog: logArr\n      };\n    }\n    return null;\n  }\n\n  // Check instant win at the start\n  const winStart = checkGoldWin(game, agent, log);\n  if (winStart) return winStart;\n\n  // Do not mark wall cells as visited/explored, and treat as stuck if agent is on a wall (defensive)\n  if (currCell.type === 'wall') {\n    log.push('Agent is stuck on a wall cell. This should not happen.');\n    return {\n      ...game,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = {\n    x: curr.x,\n    y: curr.y\n  };\n\n  // Always check for gold at the agent's current position after any move or backtrack\n  if (game.agentPos.x === game.goldPos.x && game.agentPos.y === game.goldPos.y) {\n    log.push(`Agent found the gold! WON! (at ${game.agentPos.x + 1},${game.agentPos.y + 1})`);\n    return {\n      ...game,\n      status: 'won',\n      actionLog: log\n    };\n  }\n\n  // Check for threats at current cell (remove duplicate gold win logic)\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'pit') {\n    log.push(`Agent fell into a pit at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'wumpus') {\n    log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({\n      x,\n      y\n    });\n    // Exclude wall cells from teleport destinations\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) {\n      if (game.board[y][x].type === 'wall') {\n        // Remove any wall cell from empty[] if present\n        const idx = empty.findIndex(pos => pos.x === x && pos.y === y);\n        if (idx !== -1) empty.splice(idx, 1);\n      }\n    }\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = {\n        x: empty[idx].x,\n        y: empty[idx].y\n      };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'pit') {\n        log.push(`Agent fell into a pit at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n        return {\n          ...game,\n          agentPos: {\n            x: pos.x,\n            y: pos.y\n          },\n          status: 'won',\n          actionLog: log\n        };\n      }\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus2 = false,\n    sensedPit2 = false,\n    sensedBat2 = false;\n  for (const n of adj) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus2 = true;\n    if (t === 'pit') sensedPit2 = true;\n    if (t === 'bat') sensedBat2 = true;\n  }\n  if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit2) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat2) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor = null;\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    log.push(`You are lucky, gold is near! (at ${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // --- MOVEMENT: DFS or A* ---\n  if (algorithm === 'astar') {\n    // Use A* to find path to gold (excluding current cell)\n    const path = aStarPath(game, curr, game.goldPos);\n    if (path.length > 1) {\n      // Move to next cell in path\n      const next = path[1];\n      agent.stack.push(next);\n    } else {\n      // No path found or already at gold\n      agent.stack.pop();\n    }\n  } else {\n    // DFS logic (as before)\n    let moved = false;\n    if (goldNeighbor && game.board[goldNeighbor.y][goldNeighbor.x].type !== 'wall') {\n      agent.stack.push(goldNeighbor);\n      moved = true;\n    } else {\n      const neighbors = getAdjacent(curr.x, curr.y);\n      for (const n of neighbors) {\n        if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type !== 'wall') {\n          agent.stack.push(n);\n          moved = true;\n          break;\n        }\n      }\n    }\n    if (!moved) {\n      agent.stack.pop();\n    }\n  }\n\n  // Only mark as visited and log for the cell the agent actually moves to\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    if ((game.agentPos.x !== pos.x || game.agentPos.y !== pos.y) && game.board[pos.y][pos.x].type !== 'wall') {\n      agent.visited[pos.y][pos.x] = true;\n      game.explored[pos.y][pos.x] = true;\n    }\n    game.agentPos = {\n      x: pos.x,\n      y: pos.y\n    };\n    const winAfterStackMove = checkGoldWin(game, agent, log);\n    if (winAfterStackMove) return winAfterStackMove;\n    // Sensory warnings for new cell (after move)\n    let sensedWumpus2 = false,\n      sensedPit2 = false,\n      sensedBat2 = false;\n    const neighbors = getAdjacent(pos.x, pos.y);\n    for (const n of neighbors) {\n      const t = game.board[n.y][n.x].type;\n      if (t === 'wumpus') sensedWumpus2 = true;\n      if (t === 'pit') sensedPit2 = true;\n      if (t === 'bat') sensedBat2 = true;\n    }\n    if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedPit2) log.push(`You feel a breeze nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedBat2) log.push(`You hear flapping nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push(`You are lucky, gold is near! (at ${pos.x + 1},${pos.y + 1})`);\n    }\n    // Always check for gold/pit/wumpus at the new cell, even if already visited\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'won',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent tried to move into a wall cell. This should not happen.');\n      return {\n        ...game,\n        status: 'lost',\n        actionLog: log\n      };\n    }\n  } else {\n    // If stack is empty, check for win/loss at current position as well\n    const pos = game.agentPos;\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'won',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return {\n        ...game,\n        agentPos: {\n          x: pos.x,\n          y: pos.y\n        },\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent is stuck on a wall cell. This should not happen.');\n      return {\n        ...game,\n        status: 'lost',\n        actionLog: log\n      };\n    }\n    log.push('No moves left. Agent is stuck.');\n    return {\n      ...game,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  return {\n    ...game,\n    actionLog: log\n  };\n}\n\n// A* pathfinding: returns a path from start to goal, or [] if no path\nexport function aStarPath(game, start, goal) {\n  // Only allow movement on empty, gold, or bat cells (not wall, pit, wumpus)\n  function isPassable(x, y) {\n    const t = game.board[y][x].type;\n    return t === 'empty' || t === 'gold' || t === 'bat';\n  }\n  function heuristic(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); // Manhattan distance\n  }\n  const open = [];\n  const closed = new Set();\n  open.push({\n    x: start.x,\n    y: start.y,\n    f: heuristic(start, goal),\n    g: 0\n  });\n  while (open.length > 0) {\n    // Get node with lowest f\n    open.sort((a, b) => a.f - b.f);\n    const current = open.shift();\n    if (current.x === goal.x && current.y === goal.y) {\n      // Reconstruct path\n      const path = [];\n      let node = current;\n      while (node) {\n        path.push({\n          x: node.x,\n          y: node.y\n        });\n        node = node.parent;\n      }\n      return path.reverse();\n    }\n    closed.add(`${current.x},${current.y}`);\n    for (const {\n      dx,\n      dy\n    } of DIRS) {\n      const nx = current.x + dx,\n        ny = current.y + dy;\n      if (!isValid(nx, ny) || !isPassable(nx, ny) || closed.has(`${nx},${ny}`)) continue;\n      const g = current.g + 1;\n      const h = heuristic({\n        x: nx,\n        y: ny\n      }, goal);\n      // If already in open with lower g, skip\n      const existing = open.find(n => n.x === nx && n.y === ny);\n      if (existing && existing.g <= g) continue;\n      open.push({\n        x: nx,\n        y: ny,\n        f: g + h,\n        g,\n        parent: current\n      });\n    }\n  }\n  return [];\n}","map":{"version":3,"names":["BOARD_SIZE","NUM_BATS","NUM_PITS","WALL_SHAPES_5","dx","dy","getRandomEmptyCell","occupied","forbidden","Set","x","y","Math","floor","random","has","add","randomWallCluster","start","minSize","maxSize","cluster","seen","frontier","length","nextFrontier","cell","adj","n","push","markForbiddenArea","center","skipCenter","createNewGame","stats","NUM_WALLS","wallPositions","wallCellsPlaced","shape","x0","y0","shapeCells","map","every","forEach","agentPos","wumpusPos","goldPos","batPositions","i","pos","pitPositions","board","Array","from","_","some","w","type","explored","revealed","fill","status","actionLog","agentState","createAgentState","stack","visited","arrows","path","autoMode","DIRS","shuffle","array","j","getAdjacent","dirs","filter","isValid","revealVisibleArea","game","agentStep","agent","log","curr","currCell","checks","neighbors","join","shot","checkGoldWin","g","a","logArr","winStart","empty","idx","findIndex","splice","newCell","sensedWumpus2","sensedPit2","sensedBat2","t","goldNearby","goldNeighbor","moved","pop","winAfterStackMove","goldNear","agentStepWithAlgorithm","algorithm","aStarPath","next","goal","isPassable","heuristic","b","abs","open","closed","f","sort","current","shift","node","parent","reverse","nx","ny","h","existing","find"],"sources":["/workspaces/HuntTheWumpus/hunt-the-wumpus-react/src/utils/gameLogic.ts"],"sourcesContent":["import { GameState, Cell, CellType, AgentState } from './gameTypes';\n\nconst BOARD_SIZE = 20;\nconst NUM_BATS = 6;\nconst NUM_PITS = 3;\n\n// Predefined wall cluster shapes (all size 5, all rotations)\nconst WALL_SHAPES_5 = [\n  // I shapes\n  [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:0,dy:2}, {dx:0,dy:3}, {dx:0,dy:4} ], // vertical\n  [ {dx:0,dy:0}, {dx:1,dy:0}, {dx:2,dy:0}, {dx:3,dy:0}, {dx:4,dy:0} ], // horizontal\n  // L shapes\n  [ {dx:0,dy:0}, {dx:1,dy:0}, {dx:2,dy:0}, {dx:2,dy:1}, {dx:2,dy:2} ],\n  [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:0,dy:2}, {dx:1,dy:2}, {dx:2,dy:2} ],\n  [ {dx:0,dy:0}, {dx:-1,dy:0}, {dx:-2,dy:0}, {dx:-2,dy:1}, {dx:-2,dy:2} ],\n  [ {dx:0,dy:0}, {dx:0,dy:-1}, {dx:0,dy:-2}, {dx:1,dy:-2}, {dx:2,dy:-2} ],\n  // T shapes\n  [ {dx:0,dy:0}, {dx:-1,dy:1}, {dx:0,dy:1}, {dx:1,dy:1}, {dx:0,dy:2} ],\n  [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:1,dy:0}, {dx:0,dy:-1}, {dx:-1,dy:0} ],\n  [ {dx:0,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:1,dy:0}, {dx:0,dy:-1} ],\n  [ {dx:0,dy:0}, {dx:0,dy:-1}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:1,dy:0} ],\n  // U shapes\n  [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:0,dy:2}, {dx:1,dy:0}, {dx:1,dy:2} ],\n  [ {dx:0,dy:0}, {dx:1,dy:0}, {dx:2,dy:0}, {dx:0,dy:1}, {dx:2,dy:1} ],\n  [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:0,dy:2}, {dx:-1,dy:0}, {dx:-1,dy:2} ],\n  [ {dx:0,dy:0}, {dx:-1,dy:0}, {dx:-2,dy:0}, {dx:0,dy:1}, {dx:-2,dy:1} ],\n  // Plus shape\n  [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}, {dx:1,dy:0}, {dx:-1,dy:0} ],\n  // Zigzag\n  [ {dx:0,dy:0}, {dx:1,dy:0}, {dx:1,dy:1}, {dx:2,dy:1}, {dx:2,dy:2} ],\n  [ {dx:0,dy:0}, {dx:0,dy:1}, {dx:-1,dy:1}, {dx:-1,dy:2}, {dx:-2,dy:2} ],\n];\n\nfunction getRandomEmptyCell(occupied: Set<string>, forbidden: Set<string> = new Set()): { x: number; y: number } {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`) || forbidden.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return { x, y };\n}\n\nfunction randomWallCluster(start: {x: number, y: number}, occupied: Set<string>, forbidden: Set<string>, minSize = 5, maxSize = 15): {x: number, y: number}[] {\n  const cluster: {x: number, y: number}[] = [start];\n  const seen = new Set([`${start.x},${start.y}`]);\n  let frontier = [start];\n  while (cluster.length < maxSize && frontier.length > 0) {\n    const nextFrontier: {x: number, y: number}[] = [];\n    for (const cell of frontier) {\n      const adj = [\n        {x: cell.x+1, y: cell.y}, {x: cell.x-1, y: cell.y},\n        {x: cell.x, y: cell.y+1}, {x: cell.x, y: cell.y-1}\n      ];\n      for (const n of adj) {\n        if (\n          n.x >= 0 && n.x < BOARD_SIZE && n.y >= 0 && n.y < BOARD_SIZE &&\n          !occupied.has(`${n.x},${n.y}`) && !forbidden.has(`${n.x},${n.y}`) && !seen.has(`${n.x},${n.y}`)\n        ) {\n          if (Math.random() < 0.7 || cluster.length < minSize) { // bias to grow until minSize\n            cluster.push(n);\n            nextFrontier.push(n);\n            seen.add(`${n.x},${n.y}`);\n            if (cluster.length >= maxSize) break;\n          }\n        }\n      }\n      if (cluster.length >= maxSize) break;\n    }\n    frontier = nextFrontier;\n  }\n  return cluster.length >= minSize ? cluster : [];\n}\n\nfunction markForbiddenArea(center: {x: number, y: number}, forbidden: Set<string>, skipCenter = false) {\n  for (let dy = -3; dy <= 3; dy++) {\n    for (let dx = -3; dx <= 3; dx++) {\n      const x = center.x + dx;\n      const y = center.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        if (skipCenter && dx === 0 && dy === 0) continue;\n        forbidden.add(`${x},${y}`);\n      }\n    }\n  }\n}\n\nexport function createNewGame(stats: { games: number; victories: number }): GameState {\n  const occupied = new Set<string>();\n  const forbidden = new Set<string>();\n  // Place wall clusters (predefined shapes, all size 5)\n  const NUM_WALLS = Math.floor(BOARD_SIZE * BOARD_SIZE * 0.10); // 10% of the board\n  const wallPositions: { x: number; y: number }[] = [];\n  let wallCellsPlaced = 0;\n  while (wallCellsPlaced < NUM_WALLS) {\n    // Randomly pick a shape\n    const shape = WALL_SHAPES_5[Math.floor(Math.random() * WALL_SHAPES_5.length)];\n    // Randomly pick a starting cell\n    const x0 = Math.floor(Math.random() * BOARD_SIZE);\n    const y0 = Math.floor(Math.random() * BOARD_SIZE);\n    // Compute all cells for this shape\n    const shapeCells = shape.map(({dx,dy}) => ({x: x0+dx, y: y0+dy}));\n    // Check all in bounds and not forbidden/occupied\n    if (shapeCells.every(({x,y}) => x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && !occupied.has(`${x},${y}`) && !forbidden.has(`${x},${y}`))) {\n      shapeCells.forEach(({x,y}) => {\n        wallPositions.push({x,y});\n        forbidden.add(`${x},${y}`);\n        occupied.add(`${x},${y}`);\n        wallCellsPlaced++;\n        if (wallCellsPlaced >= NUM_WALLS) return;\n      });\n    }\n    // Prevent infinite loop if board is too full\n    if (wallCellsPlaced > BOARD_SIZE*BOARD_SIZE*0.5) break;\n  }\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(agentPos, forbidden);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(wumpusPos, forbidden);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied, forbidden);\n  markForbiddenArea(goldPos, forbidden, true); // skipCenter=true: do not forbid the gold cell itself\n  // Place bats\n  const batPositions = [];\n  for (let i = 0; i < NUM_BATS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    batPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n  // Place pits\n  const pitPositions = [];\n  for (let i = 0; i < NUM_PITS; i++) {\n    const pos = getRandomEmptyCell(occupied, forbidden);\n    pitPositions.push(pos);\n    markForbiddenArea(pos, forbidden);\n  }\n\n  // Build board\n  const board: Cell[][] = Array.from({ length: BOARD_SIZE }, (_, y) =>\n    Array.from({ length: BOARD_SIZE }, (_, x) => {\n      if (wallPositions.some(w => w.x === x && w.y === y)) return { type: 'wall', explored: false };\n      return { type: 'empty', explored: false };\n    })\n  );\n  board[wumpusPos.y][wumpusPos.x] = { type: 'wumpus', explored: false };\n  batPositions.forEach(({ x, y }) => (board[y][x] = { type: 'bat', explored: false }));\n  pitPositions.forEach(({ x, y }) => (board[y][x] = { type: 'pit', explored: false }));\n  // Place gold last so it is never overwritten\n  board[goldPos.y][goldPos.x] = { type: 'gold', explored: false };\n\n  // Initialize revealed (fog) array\n  const revealed = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false));\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      const x = agentPos.x + dx;\n      const y = agentPos.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        revealed[y][x] = true;\n      }\n    }\n  }\n\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    revealed, // <-- add revealed to game state\n    status: 'playing',\n    actionLog: [\n      `Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`,\n      `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`,\n      `Gold at (${goldPos.x + 1},${goldPos.y + 1})`,\n    ],\n    agentState: createAgentState(agentPos),\n  } as GameState;\n}\n\nexport function createAgentState(agentPos: { x: number; y: number }): AgentState {\n  return {\n    stack: [agentPos],\n    visited: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    path: [agentPos],\n    autoMode: true,\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [\n  { dx: 0, dy: -1 },  // up\n  { dx: 1, dy: 0 },   // right\n  { dx: 0, dy: 1 },   // down\n  { dx: -1, dy: 0 },  // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x: number, y: number) {\n  const dirs = shuffle([...DIRS]);\n  return dirs\n    .map(({ dx, dy }) => ({ x: x + dx, y: y + dy }))\n    .filter(({ x, y }) => isValid(x, y));\n}\n\nfunction isValid(x: number, y: number) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper to update the revealed (fog) array for the agent's visible area\nfunction revealVisibleArea(game: GameState) {\n  const { agentPos, revealed } = game;\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      const x = agentPos.x + dx;\n      const y = agentPos.y + dy;\n      if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n        revealed[y][x] = true;\n      }\n    }\n  }\n}\n\nexport function agentStep(game: GameState): GameState {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // --- DETAILED LOGGING: Log all checks performed at this cell ---\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  const currCell = game.board[curr.y][curr.x];\n  const checks = [];\n  if (currCell.type === 'gold') checks.push('gold');\n  if (currCell.type === 'pit') checks.push('pit');\n  if (currCell.type === 'wumpus') checks.push('wumpus');\n  if (currCell.type === 'bat') checks.push('bat');\n  if (currCell.type === 'wall') checks.push('wall');\n  // Always check for adjacent threats\n  const adj = getAdjacent(curr.x, curr.y);\n  const neighbors = getAdjacent(curr.x, curr.y); // <-- Fix: define neighbors for DFS and sensory logic\n  if (adj.some(n => game.board[n.y][n.x].type === 'wumpus')) checks.push('adjacent wumpus');\n  if (adj.some(n => game.board[n.y][n.x].type === 'pit')) checks.push('adjacent pit');\n  if (adj.some(n => game.board[n.y][n.x].type === 'bat')) checks.push('adjacent bat');\n  if (adj.some(n => game.board[n.y][n.x].type === 'gold')) checks.push('adjacent gold');\n  if (adj.some(n => game.board[n.y][n.x].type === 'wall')) checks.push('adjacent wall');\n  log.push(`[LOG] Agent at (${curr.x + 1},${curr.y + 1}): checked for ${checks.length ? checks.join(', ') : 'nothing special'}`);\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible (ALWAYS do this before moving) ---\n  let shot = false;\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return { ...game, status: 'won', actionLog: log };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      shot = true;\n      break; // Only shoot once per step\n    }\n  }\n\n  // Helper to check instant win after any move\n  function checkGoldWin(g: GameState, a: typeof agent, logArr: string[]) {\n    if (g.agentPos.x === g.goldPos.x && g.agentPos.y === g.goldPos.y) {\n      logArr.push(`Agent found the gold! WON! (at ${g.agentPos.x + 1},${g.agentPos.y + 1})`);\n      return { ...g, status: 'won' as const, actionLog: logArr };\n    }\n    return null;\n  }\n\n  // Check instant win at the start\n  const winStart = checkGoldWin(game, agent, log);\n  if (winStart) return winStart;\n\n  // Do not mark wall cells as visited/explored, and treat as stuck if agent is on a wall (defensive)\n  if (currCell.type === 'wall') {\n    log.push('Agent is stuck on a wall cell. This should not happen.');\n    return { ...game, status: 'lost', actionLog: log };\n  }\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = { x: curr.x, y: curr.y };\n\n  // Always check for gold at the agent's current position after any move or backtrack\n  if (game.agentPos.x === game.goldPos.x && game.agentPos.y === game.goldPos.y) {\n    log.push(`Agent found the gold! WON! (at ${game.agentPos.x + 1},${game.agentPos.y + 1})`);\n    return { ...game, status: 'won', actionLog: log };\n  }\n\n  // Check for threats at current cell (remove duplicate gold win logic)\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'pit') {\n    log.push(`Agent fell into a pit at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'wumpus') {\n    log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty: { x: number; y: number }[] = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++)\n      if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({ x, y });\n    // Exclude wall cells from teleport destinations\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) {\n      if (game.board[y][x].type === 'wall') {\n        // Remove any wall cell from empty[] if present\n        const idx = empty.findIndex(pos => pos.x === x && pos.y === y);\n        if (idx !== -1) empty.splice(idx, 1);\n      }\n    }\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = { x: empty[idx].x, y: empty[idx].y };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'won', actionLog: log };\n      }\n      if (newCell.type === 'pit') {\n        log.push(`Agent fell into a pit at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n        return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n      }\n      return { ...game, actionLog: log };\n    }\n  }\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus2 = false, sensedPit2 = false, sensedBat2 = false;\n  for (const n of adj) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus2 = true;\n    if (t === 'pit') sensedPit2 = true;\n    if (t === 'bat') sensedBat2 = true;\n  }\n  if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit2) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat2) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor: { x: number; y: number } | null = null;\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    log.push(`You are lucky, gold is near! (at ${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // --- DFS MOVEMENT: Choose next move ---\n  let moved = false;\n  // If gold is adjacent and not a wall, move to it immediately (even if visited)\n  if (goldNeighbor && game.board[goldNeighbor.y][goldNeighbor.x].type !== 'wall') {\n    agent.stack.push(goldNeighbor);\n    moved = true;\n  } else {\n    // Prefer unvisited, non-wall neighbor if gold is not adjacent\n    for (const n of neighbors) {\n      if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type !== 'wall') {\n        agent.stack.push(n);\n        moved = true;\n        break;\n      }\n    }\n  }\n  // If still no move, backtrack\n  if (!moved) {\n    agent.stack.pop();\n  }\n  // Only mark as visited and log for the cell the agent actually moves to\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    // Only mark as visited if the agent is actually moving to this cell now and it's not a wall\n    if ((game.agentPos.x !== pos.x || game.agentPos.y !== pos.y) && game.board[pos.y][pos.x].type !== 'wall') {\n      agent.visited[pos.y][pos.x] = true;\n      game.explored[pos.y][pos.x] = true;\n    }\n    game.agentPos = { x: pos.x, y: pos.y };\n    // Check instant win after agentPos update (including backtracking)\n    const winAfterStackMove = checkGoldWin(game, agent, log);\n    if (winAfterStackMove) return winAfterStackMove;\n    // Sensory warnings for new cell (after move)\n    let sensedWumpus2 = false, sensedPit2 = false, sensedBat2 = false;\n    for (const n of neighbors) {\n      const t = game.board[n.y][n.x].type;\n      if (t === 'wumpus') sensedWumpus2 = true;\n      if (t === 'pit') sensedPit2 = true;\n      if (t === 'bat') sensedBat2 = true;\n    }\n    if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedPit2) log.push(`You feel a breeze nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedBat2) log.push(`You hear flapping nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push(`You are lucky, gold is near! (at ${pos.x + 1},${pos.y + 1})`);\n    }\n    // Always check for gold/pit/wumpus at the new cell, even if already visited\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent tried to move into a wall cell. This should not happen.');\n      return { ...game, status: 'lost', actionLog: log };\n    }\n  } else {\n    // If stack is empty, check for win/loss at current position as well\n    const pos = game.agentPos;\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent is stuck on a wall cell. This should not happen.');\n      return { ...game, status: 'lost', actionLog: log };\n    }\n    log.push('No moves left. Agent is stuck.');\n    return { ...game, status: 'lost', actionLog: log };\n  }\n  return { ...game, actionLog: log };\n}\n\n// Agent step with algorithm selector: uses DFS or A* based on game.agentState.algorithm (default: DFS)\nexport function agentStepWithAlgorithm(game: GameState, algorithm: 'dfs' | 'astar'): GameState {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // --- DETAILED LOGGING: Log all checks performed at this cell ---\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  const currCell = game.board[curr.y][curr.x];\n  const checks = [];\n  if (currCell.type === 'gold') checks.push('gold');\n  if (currCell.type === 'pit') checks.push('pit');\n  if (currCell.type === 'wumpus') checks.push('wumpus');\n  if (currCell.type === 'bat') checks.push('bat');\n  if (currCell.type === 'wall') checks.push('wall');\n  // Always check for adjacent threats\n  const adj = getAdjacent(curr.x, curr.y);\n  if (adj.some(n => game.board[n.y][n.x].type === 'wumpus')) checks.push('adjacent wumpus');\n  if (adj.some(n => game.board[n.y][n.x].type === 'pit')) checks.push('adjacent pit');\n  if (adj.some(n => game.board[n.y][n.x].type === 'bat')) checks.push('adjacent bat');\n  if (adj.some(n => game.board[n.y][n.x].type === 'gold')) checks.push('adjacent gold');\n  if (adj.some(n => game.board[n.y][n.x].type === 'wall')) checks.push('adjacent wall');\n  log.push(`Agent at (${curr.x + 1},${curr.y + 1}): checked for ${checks.length ? checks.join(', ') : 'nothing special'}`);\n\n  // --- WUMPUS SHOOTING LOGIC: Check for adjacent Wumpus and shoot if possible (ALWAYS do this before moving) ---\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n      agent.arrows--;\n      log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n      // 1/8 probability to hit\n      if (Math.random() < 0.125) {\n        game.board[n.y][n.x].type = 'empty';\n        log.push('Agent killed the Wumpus! WON!');\n        return { ...game, status: 'won', actionLog: log };\n      } else {\n        log.push('Agent missed the Wumpus and continues exploring.');\n      }\n      break; // Only shoot once per step\n    }\n  }\n\n  // Helper to check instant win after any move\n  function checkGoldWin(g: GameState, a: typeof agent, logArr: string[]) {\n    if (g.agentPos.x === g.goldPos.x && g.agentPos.y === g.goldPos.y) {\n      logArr.push(`Agent found the gold! WON! (at ${g.agentPos.x + 1},${g.agentPos.y + 1})`);\n      return { ...g, status: 'won' as const, actionLog: logArr };\n    }\n    return null;\n  }\n\n  // Check instant win at the start\n  const winStart = checkGoldWin(game, agent, log);\n  if (winStart) return winStart;\n\n  // Do not mark wall cells as visited/explored, and treat as stuck if agent is on a wall (defensive)\n  if (currCell.type === 'wall') {\n    log.push('Agent is stuck on a wall cell. This should not happen.');\n    return { ...game, status: 'lost', actionLog: log };\n  }\n  agent.visited[curr.y][curr.x] = true;\n  game.explored[curr.y][curr.x] = true;\n  game.agentPos = { x: curr.x, y: curr.y };\n\n  // Always check for gold at the agent's current position after any move or backtrack\n  if (game.agentPos.x === game.goldPos.x && game.agentPos.y === game.goldPos.y) {\n    log.push(`Agent found the gold! WON! (at ${game.agentPos.x + 1},${game.agentPos.y + 1})`);\n    return { ...game, status: 'won', actionLog: log };\n  }\n\n  // Check for threats at current cell (remove duplicate gold win logic)\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'pit') {\n    log.push(`Agent fell into a pit at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'wumpus') {\n    log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${curr.x + 1},${curr.y + 1})`);\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty: { x: number; y: number }[] = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++)\n      if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({ x, y });\n    // Exclude wall cells from teleport destinations\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) {\n      if (game.board[y][x].type === 'wall') {\n        // Remove any wall cell from empty[] if present\n        const idx = empty.findIndex(pos => pos.x === x && pos.y === y);\n        if (idx !== -1) empty.splice(idx, 1);\n      }\n    }\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      game.agentPos = { x: empty[idx].x, y: empty[idx].y };\n      // After teleport, check for threats at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'won', actionLog: log };\n      }\n      if (newCell.type === 'pit') {\n        log.push(`Agent fell into a pit at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${empty[idx].x + 1},${empty[idx].y + 1})`);\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, status: 'lost', actionLog: log };\n      }\n      // Also check if the new cell is gold after stack update (for consistency)\n      const pos = agent.stack[agent.stack.length - 1];\n      if (game.board[pos.y][pos.x].type === 'gold') {\n        log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n        return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n      }\n      return { ...game, actionLog: log };\n    }\n  }\n\n  // --- SENSORY WARNINGS: Check for adjacent threats and log warnings ---\n  let sensedWumpus2 = false, sensedPit2 = false, sensedBat2 = false;\n  for (const n of adj) {\n    const t = game.board[n.y][n.x].type;\n    if (t === 'wumpus') sensedWumpus2 = true;\n    if (t === 'pit') sensedPit2 = true;\n    if (t === 'bat') sensedBat2 = true;\n  }\n  if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedPit2) log.push(`You feel a breeze nearby. (at ${curr.x + 1},${curr.y + 1})`);\n  if (sensedBat2) log.push(`You hear flapping nearby. (at ${curr.x + 1},${curr.y + 1})`);\n\n  // --- GOLD SENSING: Check for adjacent gold and log, always prioritize unvisited neighbors if gold is near ---\n  let goldNearby = false;\n  let goldNeighbor: { x: number; y: number } | null = null;\n  for (const n of adj) {\n    if (game.board[n.y][n.x].type === 'gold') {\n      goldNearby = true;\n      goldNeighbor = n;\n    }\n  }\n  if (goldNearby) {\n    log.push(`You are lucky, gold is near! (at ${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // --- MOVEMENT: DFS or A* ---\n  if (algorithm === 'astar') {\n    // Use A* to find path to gold (excluding current cell)\n    const path = aStarPath(game, curr, game.goldPos);\n    if (path.length > 1) {\n      // Move to next cell in path\n      const next = path[1];\n      agent.stack.push(next);\n    } else {\n      // No path found or already at gold\n      agent.stack.pop();\n    }\n  } else {\n    // DFS logic (as before)\n    let moved = false;\n    if (goldNeighbor && game.board[goldNeighbor.y][goldNeighbor.x].type !== 'wall') {\n      agent.stack.push(goldNeighbor);\n      moved = true;\n    } else {\n      const neighbors = getAdjacent(curr.x, curr.y);\n      for (const n of neighbors) {\n        if (!agent.visited[n.y][n.x] && game.board[n.y][n.x].type !== 'wall') {\n          agent.stack.push(n);\n          moved = true;\n          break;\n        }\n      }\n    }\n    if (!moved) {\n      agent.stack.pop();\n    }\n  }\n\n  // Only mark as visited and log for the cell the agent actually moves to\n  if (agent.stack.length > 0) {\n    const pos = agent.stack[agent.stack.length - 1];\n    if ((game.agentPos.x !== pos.x || game.agentPos.y !== pos.y) && game.board[pos.y][pos.x].type !== 'wall') {\n      agent.visited[pos.y][pos.x] = true;\n      game.explored[pos.y][pos.x] = true;\n    }\n    game.agentPos = { x: pos.x, y: pos.y };\n    const winAfterStackMove = checkGoldWin(game, agent, log);\n    if (winAfterStackMove) return winAfterStackMove;\n    // Sensory warnings for new cell (after move)\n    let sensedWumpus2 = false, sensedPit2 = false, sensedBat2 = false;\n    const neighbors = getAdjacent(pos.x, pos.y);\n    for (const n of neighbors) {\n      const t = game.board[n.y][n.x].type;\n      if (t === 'wumpus') sensedWumpus2 = true;\n      if (t === 'pit') sensedPit2 = true;\n      if (t === 'bat') sensedBat2 = true;\n    }\n    if (sensedWumpus2) log.push(`You smell something terrible nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedPit2) log.push(`You feel a breeze nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    if (sensedBat2) log.push(`You hear flapping nearby. (at ${pos.x + 1},${pos.y + 1})`);\n    // After moving, check for gold in neighbors and log if found\n    const goldNear = getAdjacent(pos.x, pos.y).some(n => game.board[n.y][n.x].type === 'gold');\n    if (goldNear) {\n      log.push(`You are lucky, gold is near! (at ${pos.x + 1},${pos.y + 1})`);\n    }\n    // Always check for gold/pit/wumpus at the new cell, even if already visited\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent tried to move into a wall cell. This should not happen.');\n      return { ...game, status: 'lost', actionLog: log };\n    }\n  } else {\n    // If stack is empty, check for win/loss at current position as well\n    const pos = game.agentPos;\n    const cell = game.board[pos.y][pos.x];\n    if (cell.type === 'gold') {\n      log.push(`Agent found the gold! WON! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'won', actionLog: log };\n    }\n    if (cell.type === 'pit') {\n      log.push(`Agent fell into a pit at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wumpus') {\n      log.push(`Agent encountered the Wumpus at this cell. Lost! (at ${pos.x + 1},${pos.y + 1})`);\n      return { ...game, agentPos: { x: pos.x, y: pos.y }, status: 'lost', actionLog: log };\n    }\n    if (cell.type === 'wall') {\n      log.push('Agent is stuck on a wall cell. This should not happen.');\n      return { ...game, status: 'lost', actionLog: log };\n    }\n    log.push('No moves left. Agent is stuck.');\n    return { ...game, status: 'lost', actionLog: log };\n  }\n  return { ...game, actionLog: log };\n}\n\n// A* pathfinding: returns a path from start to goal, or [] if no path\nexport function aStarPath(game: GameState, start: {x: number, y: number}, goal: {x: number, y: number}): {x: number, y: number}[] {\n  // Only allow movement on empty, gold, or bat cells (not wall, pit, wumpus)\n  function isPassable(x: number, y: number) {\n    const t = game.board[y][x].type;\n    return t === 'empty' || t === 'gold' || t === 'bat';\n  }\n  function heuristic(a: {x: number, y: number}, b: {x: number, y: number}) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); // Manhattan distance\n  }\n  const open: Array<{x: number, y: number, f: number, g: number, parent?: {x: number, y: number}}>=[];\n  const closed = new Set<string>();\n  open.push({x: start.x, y: start.y, f: heuristic(start, goal), g: 0});\n  while (open.length > 0) {\n    // Get node with lowest f\n    open.sort((a, b) => a.f - b.f);\n    const current = open.shift()!;\n    if (current.x === goal.x && current.y === goal.y) {\n      // Reconstruct path\n      const path = [];\n      let node: any = current;\n      while (node) {\n        path.push({x: node.x, y: node.y});\n        node = node.parent;\n      }\n      return path.reverse();\n    }\n    closed.add(`${current.x},${current.y}`);\n    for (const {dx, dy} of DIRS) {\n      const nx = current.x + dx, ny = current.y + dy;\n      if (!isValid(nx, ny) || !isPassable(nx, ny) || closed.has(`${nx},${ny}`)) continue;\n      const g = current.g + 1;\n      const h = heuristic({x: nx, y: ny}, goal);\n      // If already in open with lower g, skip\n      const existing = open.find(n => n.x === nx && n.y === ny);\n      if (existing && existing.g <= g) continue;\n      open.push({x: nx, y: ny, f: g + h, g, parent: current});\n    }\n  }\n  return [];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}