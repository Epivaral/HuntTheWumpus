{"ast":null,"code":"const BOARD_SIZE = 20;\nconst NUM_BATS = 1;\nconst NUM_PITS = 4;\nfunction getRandomEmptyCell(occupied) {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return {\n    x,\n    y\n  };\n}\nexport function createNewGame() {\n  const occupied = new Set();\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied);\n  // Place bats\n  const batPositions = Array.from({\n    length: NUM_BATS\n  }, () => getRandomEmptyCell(occupied));\n  // Place pits\n  const pitPositions = Array.from({\n    length: NUM_PITS\n  }, () => getRandomEmptyCell(occupied));\n\n  // Build board\n  const board = Array.from({\n    length: BOARD_SIZE\n  }, (_, y) => Array.from({\n    length: BOARD_SIZE\n  }, (_, x) => ({\n    type: 'empty',\n    explored: false\n  })));\n  board[wumpusPos.y][wumpusPos.x] = {\n    type: 'wumpus',\n    explored: false\n  };\n  board[goldPos.y][goldPos.x] = {\n    type: 'gold',\n    explored: false\n  };\n  batPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'bat',\n    explored: false\n  });\n  pitPositions.forEach(({\n    x,\n    y\n  }) => board[y][x] = {\n    type: 'pit',\n    explored: false\n  });\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    stats: {\n      games: 1,\n      victories: 0\n    },\n    actionLog: [`Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`, `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`, `Gold at (${goldPos.x + 1},${goldPos.y + 1})`]\n  };\n}\nexport function createAgentState(agentPos) {\n  return {\n    stack: [agentPos],\n    visited: Array.from({\n      length: BOARD_SIZE\n    }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [{\n  dx: 0,\n  dy: -1\n},\n// up\n{\n  dx: 1,\n  dy: 0\n},\n// right\n{\n  dx: 0,\n  dy: 1\n},\n// down\n{\n  dx: -1,\n  dy: 0\n} // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x, y) {\n  const dirs = shuffle([...DIRS]);\n  return dirs.map(({\n    dx,\n    dy\n  }) => ({\n    x: x + dx,\n    y: y + dy\n  })).filter(({\n    x,\n    y\n  }) => isValid(x, y));\n}\nfunction isValid(x, y) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game, x, y) {\n  let dangerLevel = 0;\n  let adjWumpus = null;\n  let adjBats = 0,\n    adjPits = 0;\n  for (const {\n    x: nx,\n    y: ny\n  } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = {\n        x: nx,\n        y: ny\n      };\n    } else if (t === 'pit') {\n      dangerLevel += 10;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return {\n    dangerLevel,\n    adjWumpus,\n    adjBats,\n    adjPits\n  };\n}\nexport function agentStep(game) {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n\n  // Always get the current cell, even if stack is empty\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // --- FINAL STRICT MOVE VALIDATION: Only allow adjacent moves (except bat teleport) ---\n  if (game.prevAgentPos) {\n    const dx = Math.abs(curr.x - game.prevAgentPos.x);\n    const dy = Math.abs(curr.y - game.prevAgentPos.y);\n    const isAdjacent = dx + dy === 1;\n    const isTeleport = log.length > 0 && log[log.length - 1].includes('bats');\n    if (!isAdjacent && !isTeleport) {\n      log.push(`ILLEGAL MOVE DETECTED: Agent tried to jump from (${game.prevAgentPos.x + 1},${game.prevAgentPos.y + 1}) to (${curr.x + 1},${curr.y + 1}) - move ignored`);\n      // Remove the illegal move from stack and path if present\n      if (agent.stack.length > 0) agent.stack.pop();\n      if (agent.path.length > 0) agent.path.pop();\n      // Revert agent position\n      game.agentPos = {\n        ...game.prevAgentPos\n      };\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n  game.prevAgentPos = {\n    x: curr.x,\n    y: curr.y\n  };\n  game.agentPos = {\n    x: curr.x,\n    y: curr.y\n  };\n\n  // Only log move if stack is not empty (i.e., a real move)\n  if (agent.stack.length > 0) {\n    agent.visited[curr.y][curr.x] = true;\n    game.explored[curr.y][curr.x] = true;\n    log.push(`Agent moved to (${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // 1. Always check for threats (gold, pit, wumpus, bat) by cell type FIRST and return immediately if found\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'gold' && !agent.hasGold) {\n    agent.hasGold = true;\n    log.push('Agent found the gold! WON!');\n    const newExplored = game.explored.map((row, j) => row.map((val, i) => i === curr.x && j === curr.y ? true : val));\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      explored: newExplored,\n      status: 'won',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'pit') {\n    log.push('Agent fell into a pit at this cell. Lost!');\n    const newExplored = game.explored.map((row, j) => row.map((val, i) => i === curr.x && j === curr.y ? true : val));\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      explored: newExplored,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'wumpus') {\n    log.push('Agent encountered the Wumpus at this cell. Lost!');\n    const newExplored = game.explored.map((row, j) => row.map((val, i) => i === curr.x && j === curr.y ? true : val));\n    return {\n      ...game,\n      agentPos: {\n        x: curr.x,\n        y: curr.y\n      },\n      explored: newExplored,\n      status: 'lost',\n      actionLog: log\n    };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++) if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({\n      x,\n      y\n    });\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      agent.path = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      // Update agentPos after teleport\n      game.agentPos = {\n        x: empty[idx].x,\n        y: empty[idx].y\n      };\n      game.prevAgentPos = {\n        x: empty[idx].x,\n        y: empty[idx].y\n      };\n      // After teleport, check for gold/pit/wumpus at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push('Agent found the gold! WON!');\n        const newExplored = game.explored.map((row, j) => row.map((val, i) => i === empty[idx].x && j === empty[idx].y ? true : val));\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          explored: newExplored,\n          status: 'won',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'pit') {\n        log.push('Agent fell into a pit at this cell. Lost!');\n        const newExplored = game.explored.map((row, j) => row.map((val, i) => i === empty[idx].x && j === empty[idx].y ? true : val));\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          explored: newExplored,\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push('Agent encountered the Wumpus at this cell. Lost!');\n        const newExplored = game.explored.map((row, j) => row.map((val, i) => i === empty[idx].x && j === empty[idx].y ? true : val));\n        return {\n          ...game,\n          agentPos: {\n            x: empty[idx].x,\n            y: empty[idx].y\n          },\n          explored: newExplored,\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n\n  // 2. If stack is empty after all checks, then agent truly ran out of moves\n  if (agent.stack.length === 0) {\n    if (game.status === 'playing') {\n      const lastLog = log.slice(-1)[0] || '';\n      if (/Lost!|WON!/i.test(lastLog)) {\n        return {\n          ...game,\n          status: 'lost',\n          actionLog: log\n        };\n      }\n      return {\n        ...game,\n        status: 'lost',\n        actionLog: [...log, 'Agent ran out of moves. Lost!']\n      };\n    } else {\n      return game;\n    }\n  }\n\n  // 3. Detect adjacent threats and log sensory messages\n  const {\n    dangerLevel,\n    adjWumpus,\n    adjBats,\n    adjPits\n  } = detectThreats(game, curr.x, curr.y);\n  if (adjWumpus) log.push('You smell something terrible nearby.');\n  if (adjPits) log.push('You feel a breeze nearby.');\n  if (adjBats) log.push('You hear flapping nearby.');\n\n  // 4. Wumpus shooting logic: shoot if adjacent and has arrows\n  if (adjWumpus && agent.arrows > 0 && !agent.justShot) {\n    agent.arrows--;\n    agent.justShot = true;\n    const hit = Math.random() < 0.125;\n    log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n    if (hit) {\n      game.board[adjWumpus.y][adjWumpus.x].type = 'empty';\n      log.push('Agent killed the Wumpus! WON!');\n      return {\n        ...game,\n        status: 'won',\n        actionLog: log\n      };\n    } else {\n      log.push('Agent missed the Wumpus and continues exploring.');\n    }\n  } else if (adjWumpus && agent.arrows === 0) {\n    log.push('Agent senses the Wumpus nearby but has no arrows left. Must continue exploring.');\n  }\n  if (agent.justShot) agent.justShot = false;\n\n  // 5. Pit/backtrack logic\n  if (adjPits > 0) {\n    log.push('Agent senses a pit nearby and backtracks.');\n    agent.stack.pop();\n    return {\n      ...game,\n      actionLog: log\n    };\n  }\n  if (adjBats > 0) {\n    log.push('Agent hears bats nearby, will risk once.');\n  }\n  const neighbors = getAdjacent(curr.x, curr.y);\n  let hazardousNeighbor = null;\n  for (const n of neighbors) {\n    // Strict adjacency check before pushing any move\n    const dx = Math.abs(n.x - curr.x);\n    const dy = Math.abs(n.y - curr.y);\n    if (dx + dy !== 1) continue; // Only allow up/down/left/right\n    if (!agent.visited[n.y][n.x]) {\n      // --- WUMPUS LOOKAHEAD SHOOTING LOGIC ---\n      if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n        agent.arrows--;\n        agent.justShot = true;\n        const hit = Math.random() < 0.125;\n        log.push(`Agent sees the Wumpus ahead at (${n.x + 1},${n.y + 1}) and shoots. Arrows left: ${agent.arrows}`);\n        if (hit) {\n          game.board[n.y][n.x].type = 'empty';\n          log.push('Agent killed the Wumpus! WON!');\n          return {\n            ...game,\n            status: 'won',\n            actionLog: log\n          };\n        } else {\n          log.push('Agent missed the Wumpus and continues exploring.');\n        }\n      } else if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows === 0) {\n        log.push(`Agent sees the Wumpus ahead at (${n.x + 1},${n.y + 1}) but has no arrows left. Must risk moving.`);\n      }\n      // --- GOLD/PIT LOOKAHEAD LOGIC ---\n      if (game.board[n.y][n.x].type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push(`Agent sees gold ahead at (${n.x + 1},${n.y + 1}) and collects it! WON!`);\n        const newExplored = game.explored.map((row, j) => row.map((val, i) => i === n.x && j === n.y ? true : val));\n        game.agentPos = {\n          x: n.x,\n          y: n.y\n        };\n        game.prevAgentPos = {\n          x: n.x,\n          y: n.y\n        };\n        return {\n          ...game,\n          agentPos: {\n            x: n.x,\n            y: n.y\n          },\n          explored: newExplored,\n          status: 'won',\n          actionLog: log\n        };\n      }\n      // Instead of skipping pits, mark as hazardous and only avoid if other options exist\n      if (game.board[n.y][n.x].type === 'pit') {\n        log.push(`Agent sees a pit ahead at (${n.x + 1},${n.y + 1}) and marks it as hazardous.`);\n        if (!hazardousNeighbor) hazardousNeighbor = n;\n        agent.visited[n.y][n.x] = true;\n        continue;\n      }\n      agent.stack.push(n);\n      agent.path.push(n);\n      game.agentPos = {\n        x: n.x,\n        y: n.y\n      };\n      game.prevAgentPos = {\n        x: n.x,\n        y: n.y\n      };\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n  // If all options are visited, prefer hazardous (pit) cells before backtracking\n  if (hazardousNeighbor) {\n    const dx = Math.abs(hazardousNeighbor.x - curr.x);\n    const dy = Math.abs(hazardousNeighbor.y - curr.y);\n    if (dx + dy === 1) {\n      log.push(`Agent has no safe moves left and risks moving into pit at (${hazardousNeighbor.x + 1},${hazardousNeighbor.y + 1}).`);\n      agent.stack.push(hazardousNeighbor);\n      agent.path.push(hazardousNeighbor);\n      game.agentPos = {\n        x: hazardousNeighbor.x,\n        y: hazardousNeighbor.y\n      };\n      game.prevAgentPos = {\n        x: hazardousNeighbor.x,\n        y: hazardousNeighbor.y\n      };\n      return {\n        ...game,\n        actionLog: log\n      };\n    }\n  }\n  log.push('All options explored, backtracking.');\n  agent.stack.pop();\n  return {\n    ...game,\n    actionLog: log\n  };\n}","map":{"version":3,"names":["BOARD_SIZE","NUM_BATS","NUM_PITS","getRandomEmptyCell","occupied","x","y","Math","floor","random","has","add","createNewGame","Set","agentPos","wumpusPos","goldPos","batPositions","Array","from","length","pitPositions","board","_","type","explored","forEach","fill","status","stats","games","victories","actionLog","createAgentState","stack","visited","arrows","hasGold","path","autoMode","DIRS","dx","dy","shuffle","array","i","j","getAdjacent","dirs","map","filter","isValid","detectThreats","game","dangerLevel","adjWumpus","adjBats","adjPits","nx","ny","t","agentStep","agentState","agent","curr","log","prevAgentPos","abs","isAdjacent","isTeleport","includes","push","pop","cell","newExplored","row","val","empty","idx","newCell","lastLog","slice","test","justShot","hit","neighbors","hazardousNeighbor","n"],"sources":["/workspaces/HuntTheWumpus/hunt-the-wumpus-react/src/utils/gameLogic.ts"],"sourcesContent":["import { GameState, Cell, CellType, AgentState } from './gameTypes';\n\nconst BOARD_SIZE = 20;\nconst NUM_BATS = 1;\nconst NUM_PITS = 4;\n\nfunction getRandomEmptyCell(occupied: Set<string>): { x: number; y: number } {\n  let x, y;\n  do {\n    x = Math.floor(Math.random() * BOARD_SIZE);\n    y = Math.floor(Math.random() * BOARD_SIZE);\n  } while (occupied.has(`${x},${y}`));\n  occupied.add(`${x},${y}`);\n  return { x, y };\n}\n\nexport function createNewGame(): GameState {\n  const occupied = new Set<string>();\n  // Place agent\n  const agentPos = getRandomEmptyCell(occupied);\n  // Place wumpus\n  const wumpusPos = getRandomEmptyCell(occupied);\n  // Place gold\n  const goldPos = getRandomEmptyCell(occupied);\n  // Place bats\n  const batPositions = Array.from({ length: NUM_BATS }, () => getRandomEmptyCell(occupied));\n  // Place pits\n  const pitPositions = Array.from({ length: NUM_PITS }, () => getRandomEmptyCell(occupied));\n\n  // Build board\n  const board: Cell[][] = Array.from({ length: BOARD_SIZE }, (_, y) =>\n    Array.from({ length: BOARD_SIZE }, (_, x) => ({ type: 'empty', explored: false }))\n  );\n  board[wumpusPos.y][wumpusPos.x] = { type: 'wumpus', explored: false };\n  board[goldPos.y][goldPos.x] = { type: 'gold', explored: false };\n  batPositions.forEach(({ x, y }) => (board[y][x] = { type: 'bat', explored: false }));\n  pitPositions.forEach(({ x, y }) => (board[y][x] = { type: 'pit', explored: false }));\n\n  return {\n    board,\n    agentPos,\n    wumpusPos,\n    goldPos,\n    batPositions,\n    pitPositions,\n    explored: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    status: 'playing',\n    stats: { games: 1, victories: 0 },\n    actionLog: [\n      `Game started. Agent at (${agentPos.x + 1},${agentPos.y + 1})`,\n      `Wumpus at (${wumpusPos.x + 1},${wumpusPos.y + 1})`,\n      `Gold at (${goldPos.x + 1},${goldPos.y + 1})`,\n    ],\n  };\n}\n\nexport function createAgentState(agentPos: { x: number; y: number }): AgentState {\n  return {\n    stack: [agentPos],\n    visited: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false)),\n    arrows: 3,\n    hasGold: false,\n    path: [agentPos],\n    autoMode: true,\n  };\n}\n\n// Directions: up, right, down, left\nconst DIRS = [\n  { dx: 0, dy: -1 },  // up\n  { dx: 1, dy: 0 },   // right\n  { dx: 0, dy: 1 },   // down\n  { dx: -1, dy: 0 },  // left\n];\n\n// Helper: shuffle an array in-place\nfunction shuffle<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// Helper: get adjacent cells in random order\nfunction getAdjacent(x: number, y: number) {\n  const dirs = shuffle([...DIRS]);\n  return dirs\n    .map(({ dx, dy }) => ({ x: x + dx, y: y + dy }))\n    .filter(({ x, y }) => isValid(x, y));\n}\n\nfunction isValid(x: number, y: number) {\n  return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\n// Helper: detect threats in adjacent cells\nfunction detectThreats(game: GameState, x: number, y: number) {\n  let dangerLevel = 0;\n  let adjWumpus: { x: number; y: number } | null = null;\n  let adjBats = 0, adjPits = 0;\n  for (const { x: nx, y: ny } of getAdjacent(x, y)) {\n    const t = game.board[ny][nx].type;\n    if (t === 'wumpus') {\n      dangerLevel += 50;\n      adjWumpus = { x: nx, y: ny };\n    } else if (t === 'pit') {\n      dangerLevel += 10;\n      adjPits++;\n    } else if (t === 'bat') {\n      dangerLevel += 10;\n      adjBats++;\n    }\n  }\n  return { dangerLevel, adjWumpus, adjBats, adjPits };\n}\n\nexport function agentStep(game: GameState): GameState {\n  if (!game.agentState || game.status !== 'playing') return game;\n  const agent = game.agentState;\n\n  // Always get the current cell, even if stack is empty\n  const curr = agent.stack.length > 0 ? agent.stack[agent.stack.length - 1] : game.agentPos;\n  let log = game.actionLog ? [...game.actionLog] : [];\n\n  // --- FINAL STRICT MOVE VALIDATION: Only allow adjacent moves (except bat teleport) ---\n  if (game.prevAgentPos) {\n    const dx = Math.abs(curr.x - game.prevAgentPos.x);\n    const dy = Math.abs(curr.y - game.prevAgentPos.y);\n    const isAdjacent = (dx + dy === 1);\n    const isTeleport = log.length > 0 && log[log.length - 1].includes('bats');\n    if (!isAdjacent && !isTeleport) {\n      log.push(`ILLEGAL MOVE DETECTED: Agent tried to jump from (${game.prevAgentPos.x + 1},${game.prevAgentPos.y + 1}) to (${curr.x + 1},${curr.y + 1}) - move ignored`);\n      // Remove the illegal move from stack and path if present\n      if (agent.stack.length > 0) agent.stack.pop();\n      if (agent.path.length > 0) agent.path.pop();\n      // Revert agent position\n      game.agentPos = { ...game.prevAgentPos };\n      return { ...game, actionLog: log };\n    }\n  }\n  game.prevAgentPos = { x: curr.x, y: curr.y };\n  game.agentPos = { x: curr.x, y: curr.y };\n\n  // Only log move if stack is not empty (i.e., a real move)\n  if (agent.stack.length > 0) {\n    agent.visited[curr.y][curr.x] = true;\n    game.explored[curr.y][curr.x] = true;\n    log.push(`Agent moved to (${curr.x + 1},${curr.y + 1})`);\n  }\n\n  // 1. Always check for threats (gold, pit, wumpus, bat) by cell type FIRST and return immediately if found\n  const cell = game.board[curr.y][curr.x];\n  if (cell.type === 'gold' && !agent.hasGold) {\n    agent.hasGold = true;\n    log.push('Agent found the gold! WON!');\n    const newExplored = game.explored.map((row, j) =>\n      row.map((val, i) => (i === curr.x && j === curr.y ? true : val))\n    );\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, explored: newExplored, status: 'won', actionLog: log };\n  }\n  if (cell.type === 'pit') {\n    log.push('Agent fell into a pit at this cell. Lost!');\n    const newExplored = game.explored.map((row, j) =>\n      row.map((val, i) => (i === curr.x && j === curr.y ? true : val))\n    );\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, explored: newExplored, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'wumpus') {\n    log.push('Agent encountered the Wumpus at this cell. Lost!');\n    const newExplored = game.explored.map((row, j) =>\n      row.map((val, i) => (i === curr.x && j === curr.y ? true : val))\n    );\n    return { ...game, agentPos: { x: curr.x, y: curr.y }, explored: newExplored, status: 'lost', actionLog: log };\n  }\n  if (cell.type === 'bat') {\n    // Bat: teleport, reset stack but keep visited and known dangers\n    const empty: { x: number; y: number }[] = [];\n    for (let y = 0; y < BOARD_SIZE; y++) for (let x = 0; x < BOARD_SIZE; x++)\n      if (game.board[y][x].type === 'empty' && !agent.visited[y][x]) empty.push({ x, y });\n    if (empty.length > 0) {\n      const idx = Math.floor(Math.random() * empty.length);\n      agent.stack = [empty[idx]];\n      agent.path = [empty[idx]];\n      log.push(`Agent was carried by bats from (${curr.x + 1},${curr.y + 1}) to (${empty[idx].x + 1},${empty[idx].y + 1})! Exploration history reset, known dangers kept.`);\n      // Update agentPos after teleport\n      game.agentPos = { x: empty[idx].x, y: empty[idx].y };\n      game.prevAgentPos = { x: empty[idx].x, y: empty[idx].y };\n      // After teleport, check for gold/pit/wumpus at new cell\n      const newCell = game.board[empty[idx].y][empty[idx].x];\n      if (newCell.type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push('Agent found the gold! WON!');\n        const newExplored = game.explored.map((row, j) =>\n          row.map((val, i) => (i === empty[idx].x && j === empty[idx].y ? true : val))\n        );\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, explored: newExplored, status: 'won', actionLog: log };\n      }\n      if (newCell.type === 'pit') {\n        log.push('Agent fell into a pit at this cell. Lost!');\n        const newExplored = game.explored.map((row, j) =>\n          row.map((val, i) => (i === empty[idx].x && j === empty[idx].y ? true : val))\n        );\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, explored: newExplored, status: 'lost', actionLog: log };\n      }\n      if (newCell.type === 'wumpus') {\n        log.push('Agent encountered the Wumpus at this cell. Lost!');\n        const newExplored = game.explored.map((row, j) =>\n          row.map((val, i) => (i === empty[idx].x && j === empty[idx].y ? true : val))\n        );\n        return { ...game, agentPos: { x: empty[idx].x, y: empty[idx].y }, explored: newExplored, status: 'lost', actionLog: log };\n      }\n      return { ...game, actionLog: log };\n    }\n  }\n\n  // 2. If stack is empty after all checks, then agent truly ran out of moves\n  if (agent.stack.length === 0) {\n    if (game.status === 'playing') {\n      const lastLog = (log).slice(-1)[0] || '';\n      if (/Lost!|WON!/i.test(lastLog)) {\n        return { ...game, status: 'lost', actionLog: log };\n      }\n      return { ...game, status: 'lost', actionLog: [...log, 'Agent ran out of moves. Lost!'] };\n    } else {\n      return game;\n    }\n  }\n\n  // 3. Detect adjacent threats and log sensory messages\n  const { dangerLevel, adjWumpus, adjBats, adjPits } = detectThreats(game, curr.x, curr.y);\n  if (adjWumpus) log.push('You smell something terrible nearby.');\n  if (adjPits) log.push('You feel a breeze nearby.');\n  if (adjBats) log.push('You hear flapping nearby.');\n\n  // 4. Wumpus shooting logic: shoot if adjacent and has arrows\n  if (adjWumpus && agent.arrows > 0 && !agent.justShot) {\n    agent.arrows--;\n    agent.justShot = true;\n    const hit = Math.random() < 0.125;\n    log.push(`Agent senses the Wumpus nearby and shoots. Arrows left: ${agent.arrows}`);\n    if (hit) {\n      game.board[adjWumpus.y][adjWumpus.x].type = 'empty';\n      log.push('Agent killed the Wumpus! WON!');\n      return { ...game, status: 'won', actionLog: log };\n    } else {\n      log.push('Agent missed the Wumpus and continues exploring.');\n    }\n  } else if (adjWumpus && agent.arrows === 0) {\n    log.push('Agent senses the Wumpus nearby but has no arrows left. Must continue exploring.');\n  }\n  if (agent.justShot) agent.justShot = false;\n\n  // 5. Pit/backtrack logic\n  if (adjPits > 0) {\n    log.push('Agent senses a pit nearby and backtracks.');\n    agent.stack.pop();\n    return { ...game, actionLog: log };\n  }\n  if (adjBats > 0) {\n    log.push('Agent hears bats nearby, will risk once.');\n  }\n  const neighbors = getAdjacent(curr.x, curr.y);\n  let hazardousNeighbor: { x: number; y: number } | null = null;\n  for (const n of neighbors) {\n    // Strict adjacency check before pushing any move\n    const dx = Math.abs(n.x - curr.x);\n    const dy = Math.abs(n.y - curr.y);\n    if (dx + dy !== 1) continue; // Only allow up/down/left/right\n    if (!agent.visited[n.y][n.x]) {\n      // --- WUMPUS LOOKAHEAD SHOOTING LOGIC ---\n      if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows > 0) {\n        agent.arrows--;\n        agent.justShot = true;\n        const hit = Math.random() < 0.125;\n        log.push(`Agent sees the Wumpus ahead at (${n.x + 1},${n.y + 1}) and shoots. Arrows left: ${agent.arrows}`);\n        if (hit) {\n          game.board[n.y][n.x].type = 'empty';\n          log.push('Agent killed the Wumpus! WON!');\n          return { ...game, status: 'won', actionLog: log };\n        } else {\n          log.push('Agent missed the Wumpus and continues exploring.');\n        }\n      } else if (game.board[n.y][n.x].type === 'wumpus' && agent.arrows === 0) {\n        log.push(`Agent sees the Wumpus ahead at (${n.x + 1},${n.y + 1}) but has no arrows left. Must risk moving.`);\n      }\n      // --- GOLD/PIT LOOKAHEAD LOGIC ---\n      if (game.board[n.y][n.x].type === 'gold' && !agent.hasGold) {\n        agent.hasGold = true;\n        log.push(`Agent sees gold ahead at (${n.x + 1},${n.y + 1}) and collects it! WON!`);\n        const newExplored = game.explored.map((row, j) =>\n          row.map((val, i) => (i === n.x && j === n.y ? true : val))\n        );\n        game.agentPos = { x: n.x, y: n.y };\n        game.prevAgentPos = { x: n.x, y: n.y };\n        return { ...game, agentPos: { x: n.x, y: n.y }, explored: newExplored, status: 'won', actionLog: log };\n      }\n      // Instead of skipping pits, mark as hazardous and only avoid if other options exist\n      if (game.board[n.y][n.x].type === 'pit') {\n        log.push(`Agent sees a pit ahead at (${n.x + 1},${n.y + 1}) and marks it as hazardous.`);\n        if (!hazardousNeighbor) hazardousNeighbor = n;\n        agent.visited[n.y][n.x] = true;\n        continue;\n      }\n      agent.stack.push(n);\n      agent.path.push(n);\n      game.agentPos = { x: n.x, y: n.y };\n      game.prevAgentPos = { x: n.x, y: n.y };\n      return { ...game, actionLog: log };\n    }\n  }\n  // If all options are visited, prefer hazardous (pit) cells before backtracking\n  if (hazardousNeighbor) {\n    const dx = Math.abs(hazardousNeighbor.x - curr.x);\n    const dy = Math.abs(hazardousNeighbor.y - curr.y);\n    if (dx + dy === 1) {\n      log.push(`Agent has no safe moves left and risks moving into pit at (${hazardousNeighbor.x + 1},${hazardousNeighbor.y + 1}).`);\n      agent.stack.push(hazardousNeighbor);\n      agent.path.push(hazardousNeighbor);\n      game.agentPos = { x: hazardousNeighbor.x, y: hazardousNeighbor.y };\n      game.prevAgentPos = { x: hazardousNeighbor.x, y: hazardousNeighbor.y };\n      return { ...game, actionLog: log };\n    }\n  }\n  log.push('All options explored, backtracking.');\n  agent.stack.pop();\n  return { ...game, actionLog: log };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}